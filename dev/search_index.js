var documenterSearchIndex = {"docs":
[{"location":"Models/inverters/#Inverter-Models-1","page":"Inverter","title":"Inverter Models","text":"","category":"section"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"Here we discuss the structure and models used to model inverters in LITS.jl. Each inverter is a data structure that is defined by the following components:","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"DC Source: Defines the dynamics of the DC side of the converter.\nFrequency Estimator: That describes how the frequency of the grid can be estimated using the grid voltages. Typically a phase-locked loop (PLL).\nOuter Loop Control: That describes the active and reactive power control dynamics.\nInner Loop Control: That can describe virtual impedance, voltage control and current control dynamics.\nConverter: That describes the dynamics of the pulse width modulation (PWM) or space vector modulation (SVM).\nFilter: Used to connect the converter output to the grid.","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"The following figure summarizes the components of a inverter and which variables they share:","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"<img src=\"../../assets/inv_metamodel.png\" width=\"75%\"/>","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"⠀","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"Contrary to the generator, there are many control structures that can be used to model inverter controllers (e.g. grid-following, grid feeding or virtual synchronous machine). For this purpose, more variables are shared among the components in order to cover all these posibilities.","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"Models are based from the paper: \"A Virtual Synchronous Machine implementation for distributed control of power converters in SmartGrids\" from S. D'Arco, J.A. Suul and O.B. Fosso, and structures are defined in PowerSystems.jl abbreviated as PSY.","category":"page"},{"location":"Models/inverters/#DC-Source-1","page":"Inverter","title":"DC Source","text":"","category":"section"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"This component can be used to model the dynamics of the DC side of the converter.","category":"page"},{"location":"Models/inverters/#Fixed-DC-Source-[PSY.FixedDCSource]-1","page":"Inverter","title":"Fixed DC Source [PSY.FixedDCSource]","text":"","category":"section"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"This is a model that set the DC voltage to a fixed value v_textdc = v_textdc^textfix.","category":"page"},{"location":"Models/inverters/#Frequency-Estimators-1","page":"Inverter","title":"Frequency Estimators","text":"","category":"section"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"This component is used to estimate the frequency of the grid based on the voltage at the bus.","category":"page"},{"location":"Models/inverters/#Phase-Locked-Loop-(PLL)-for-VSM-[PSY.PLL]-1","page":"Inverter","title":"Phase-Locked Loop (PLL) for VSM [PSY.PLL]","text":"","category":"section"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"The following equations present a PLL used to estimate the frequency and PLL angle of the grid. There are two reference frames considered in this inverter. Those are the VSM of the outer-loop control deltatheta_textolc and the PLL one deltatheta_textpll. The notation used a deltatheta to refer as the variation of the respective angle theta with respect to the grid SRF (instead of the fixed alpha component of the alphabeta transformation):","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"beginalign\ndotv_dtextpll = omega_textlp left v_d cos(deltatheta_textpll - deltatheta_textolc) + v_q sin(deltatheta_textpll - deltatheta_textolc) - v_dtextpll right tag1a \ndotv_qtextpll = omega_textlp left - v_d sin(deltatheta_textpll - deltatheta_textolc) + v_q cos(deltatheta_textpll - deltatheta_textolc) - v_qtextpll right tag1b \ndotvarepsilon_textpll = tan^-1left(fracv_qtextpllv_dtextpll right) tag1c \ndotdeltatheta_textpll = Omega_b delta omega_textpll tag1d\nendalign","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"with","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"beginalign\ndeltaomega_textpll = k_ptextpll tan^-1 left(fracv_qtextpllv_dtextpll right) + k_itextpll varepsilon_textpll tag1e\nendalign","category":"page"},{"location":"Models/inverters/#Outer-Loop-Controls-1","page":"Inverter","title":"Outer Loop Controls","text":"","category":"section"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"This component defines controllers for both active and reactive power","category":"page"},{"location":"Models/inverters/#Virtual-Inertia-and-Q-droop-[PSY.OuterControl]-1","page":"Inverter","title":"Virtual Inertia and Q-droop [PSY.OuterControl]","text":"","category":"section"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"The following model represent a virtual synchronous machine model to represent how active power is going to be deployed. The constructor is PSY.OuterControl{PSY.VirtualInertia, PSY.ReactivePowerDroop}. It defines a new SRF denoted as theta_textolc for the active power controller and uses a simple voltage droop for dispatching reactive power:","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"beginalign\n    dotdeltaomega_textolc = fracp_textrefT_a - fracp_eT_a - frack_d(omega_textolc - omega_textpll)T_a - frack_omega(omega_textolc - omega_textref)T_a tag2a \n    dotdeltatheta_textolc = Omega_b deltaomega_textolc tag2b \n    dotq_m = omega_f (q_e - q_m) tag2c\nendalign","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"with","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"beginalign\n    p_e = v_di_d + v_qi_q tag2d \n    q_e = v_qi_d - v_di_q tag2e \n    v_textolc^textref = v_textref + k_q(q_textref - q_m) tag2f\nendalign","category":"page"},{"location":"Models/inverters/#Inner-Loop-Controls-1","page":"Inverter","title":"Inner Loop Controls","text":"","category":"section"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"This component defines voltage and current controllers to generate the reference signal for the converter.","category":"page"},{"location":"Models/inverters/#Integrated-Virtual-Impedance,-Voltage-and-Current-Controller-[PSY.CombinedVIwithVZ]-1","page":"Inverter","title":"Integrated Virtual Impedance, Voltage and Current Controller [PSY.CombinedVIwithVZ]","text":"","category":"section"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"The following model receives both the outer loop control frequency and reference voltage signal to generate the reference signal for the converters. The virtual impedance plays a similar role of the impedance of a synchronous generator. A PI voltage controller is used to generate the current signal that is used in the PI current controller to finally generate the voltage reference signal for the converters.","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"beginalign*\n    dotxi_d = v_dtextvi^textref - v_d tag3a \n    dotxi_q = v_qtextvi^textref - v_q tag3b \n    dotgamma_d = i_dtextcv^textref - i_dtextcv tag3c \n    dotgamma_q = i_qtextcv^textref - i_qtextcv tag3d \n    dotphi_d = omega_textad(v_d - phi_d) tag3e \n    dotphi_q = omega_textad(v_q - phi_q) tag3f\nendalign*","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"with","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"beginalign\n    v_dtextvi^textref = v_textolc^textref - r_v i_d + omega_textolc l_v i_q tag3g \n    v_qtextvi^textref = - r_v i_q - omega_textolc l_v i_d tag3h \n    i_dtextcv^textref = k_pvleft(v_dtextvi^textref - v_qright) + k_iv xi_d - c_f omega_textolc v_q + k_textffii_d tag3i \n    i_qtextcv^textref = k_pvleft(v_qtextvi^textref - v_qright) + k_iv xi_q + c_f omega_textolc v_d + k_textffii_q tag3j \n    v_d^textref-signal = k_pc left(i_dtextcv^textref - i_dtextcvright) + k_ic gamma_d - omega_textolc l_f i_qtextcv + k_textffvv_d - k_textad(v_d - phi_d) tag3k \n    v_q^textref-signal = k_pc left(i_qtextcv^textref - i_qtextcvright) + k_ic gamma_q + omega_textolc l_f i_dtextcv + k_textffvv_q - k_textad(v_q - phi_q) tag3l\nendalign","category":"page"},{"location":"Models/inverters/#Converter-1","page":"Inverter","title":"Converter","text":"","category":"section"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"This component can be used to model the dynamics of the switching process.","category":"page"},{"location":"Models/inverters/#Average-Model-[PSY.AvgCnvFixedDC]-1","page":"Inverter","title":"Average Model [PSY.AvgCnvFixedDC]","text":"","category":"section"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"The average model simply output the desired reference signal since:","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"beginalign\nv_d^textcv approx m_d v_textdc approx fracv_d^textref-signalv_textdc v_textdc approx v_d^textref-signal tag4a \nv_q^textcv approx m_q v_textdc approx fracv_q^textref-signalv_textdc v_textdc approx v_q^textref-signal tag4b\nendalign","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"where m_dq is the modulation signal, and v_dq^textref-signal is the voltage reference signal from the inner loop control.","category":"page"},{"location":"Models/inverters/#Filters-1","page":"Inverter","title":"Filters","text":"","category":"section"},{"location":"Models/inverters/#LCL-Filter-[PSY.LCLFilter]-1","page":"Inverter","title":"LCL Filter [PSY.LCLFilter]","text":"","category":"section"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"A standard LCL filter is proposed to connect the output of the converter to the grid. In this case, v_d and v_q are voltages in the capacitor, while v_d^textgrid and v_q^textgrid represent the voltage at the bus. The L filter after the capacitor can also include a step-up transformer to increase the voltage, that is model as an extra impedance.","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"beginalign\n    doti_dtextcv = fracOmega_bl_fleft( v_d^textcv - v_d  - r_f i_dtextcv + omega_textgrid l_f i_qtextcv right) tag5a \n    doti_qtextcv = fracOmega_bl_fleft( v_q^textcv - v_q  - r_f i_qtextcv - omega_textgrid l_f i_dtextcv right) tag5b \n    dotv_d =  fracOmega_bc_fleft( i_d^textcv - i_d + omega_textgrid c_f v_q right) tag5c \n    dotv_q =  fracOmega_bc_fleft( i_q^textcv - i_q - omega_textgrid c_f v_d right) tag5d \n    doti_d = fracOmega_bl_gleft( v_d^textcv - v_d^textgrid - r_g i_d + omega_textgrid l_g i_qtextcv right) tag5e \n    doti_q = fracOmega_bl_gleft( v_q^textcv - v_q^textgrid - r_g i_q - omega_textgrid l_g i_dtextcv right) tag5f\nendalign","category":"page"},{"location":"Models/inverters/#Reference-1","page":"Inverter","title":"Reference","text":"","category":"section"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"For constructors check the API on PowerSystems.jl documentation","category":"page"},{"location":"Models/network/#Network-model-1","page":"Network","title":"Network model","text":"","category":"section"},{"location":"Models/network/#","page":"Network","title":"Network","text":"Here we discuss the models used to describe the network in LITS.jl. This is based on a standard current injection model as defined in Federico Milano's book: Power System Modelling and Scripting. The numerical advantages of current injection models outweigh the complexities of implementing constant power loads for longer-term transient stability analysis. The network is defined in a synchronous reference frame (SRF), named the RI (real-imaginary) reference frame, rotating at the constant base frequency Omega_b.","category":"page"},{"location":"Models/network/#","page":"Network","title":"Network","text":"In simple terms, LITS.jl internally tracks the current-injection balances at the nodal level from all the devices on the system. Based on the buses and branches information, the system constructor computes the admittance matrix boldsymbolY assuming nominal frequency and this is used for static branch modeling. The algebraic equations for the static portions of the network are as follows:","category":"page"},{"location":"Models/network/#","page":"Network","title":"Network","text":" beginalign\n 0 = boldsymboli(boldsymbolx boldsymbolv) - boldsymbolYboldsymbolx\n endalign","category":"page"},{"location":"Models/network/#","page":"Network","title":"Network","text":"where boldsymboli is the vector of the sum of complex current injections from devices, boldsymbolx is the vector of states and boldsymbolv is the vector of complex bus voltages. Equations (1) connect all the port variables, i.e., currents, defined for each injection device. Components that contribute to (1) by modifying the current boldsymboli are (i) static injection devices, (ii) dynamic injection devices, and (iii) dynamic network branches. Components that contribute to modify the admittance matrix boldsymbolY are static branches.","category":"page"},{"location":"Models/network/#Static-Branches-(or-simply-Branches)-1","page":"Network","title":"Static Branches (or simply Branches)","text":"","category":"section"},{"location":"Models/network/#Lines-1","page":"Network","title":"Lines","text":"","category":"section"},{"location":"Models/network/#","page":"Network","title":"Network","text":"Each line is defined using a pi model connecting two buses (nm), with a series resistance r and reactance x, and a shunt capacitance at both ends (c_n c_m). The values are already in system per unit. Then each branch contributes to the admittance matrix as follows:","category":"page"},{"location":"Models/network/#","page":"Network","title":"Network","text":"beginalign\nY_nn += frac1r+jx + jc_n \nY_nm += frac-1r+jx \nY_mm += frac1r+jx + jc_m \nY_mn += frac-1r+jx \nendalign","category":"page"},{"location":"Models/network/#Two-Windings-Transformers-1","page":"Network","title":"Two-Windings Transformers","text":"","category":"section"},{"location":"Models/network/#","page":"Network","title":"Network","text":"Similarly to lines these are defined by a series reactance and impedance. The equations are equivalently of the lines without the shunt capacitance.","category":"page"},{"location":"Models/network/#Dynamic-Branches-1","page":"Network","title":"Dynamic Branches","text":"","category":"section"},{"location":"Models/network/#","page":"Network","title":"Network","text":"Dynamic network branches contribute directly to (1) by modifying the vector of complex currents. Their parameters are also the series resistance r and reactance x, and a shunt capacitance at both ends (c_n c_m) for a line ell. In addition, they define 3 new additional differential equations per line (6 in total for real and imaginary part):","category":"page"},{"location":"Models/network/#","page":"Network","title":"Network","text":"beginalign\n    fraclOmega_b fracdi_elldt = (v_n - v_m) - (r+jl) i_ell \n     fracc_nOmega_b fracdv_ndt =  i_n^textcap - jc_nv_n   \n      fracc_mOmega_b fracdv_mdt = i_m^textcap - jc_mv_m\nendalign","category":"page"},{"location":"Models/network/#","page":"Network","title":"Network","text":"Since all the values are in per unit, the reactance is equal to the inductance.","category":"page"},{"location":"Models/small/#Small-Signal-Analysis-1","page":"Small Signal","title":"Small Signal Analysis","text":"","category":"section"},{"location":"Models/small/#","page":"Small Signal","title":"Small Signal","text":"Here we discuss the method used to do a small signal analysis on the DAE system defined in LITS.jl. The package defines algebraic variables for both real and imaginary voltages on all buses (except if they have a dynamic line connected, on which the voltage of those buses are treated as differential variables). In addition, each dynamic device can add differential variables (or states) that are concatenated to construct the system of differential algebraic equations.","category":"page"},{"location":"Models/small/#","page":"Small Signal","title":"Small Signal","text":"We define y as the vector of algebraic variables, x as the vector of differential variables (states) and p the parameters of the system, we can define g(yxp) as the vector of algebraic equations and f(yxp) as the vector of differential equations. With that, the non-linear differential algebraic system of equations can be written as:","category":"page"},{"location":"Models/small/#","page":"Small Signal","title":"Small Signal","text":"beginalign\nleftbeginarrayc\n 0 \n  dotx\n  endarrayright = leftbeginarrayc\n  g(yxp) \n   f(yxp) endarrayright\nendalign","category":"page"},{"location":"Models/small/#","page":"Small Signal","title":"Small Signal","text":"For small signal analysis, we are interested in the stability around an equilbrium point y_eqx_eq that satisfies dotx = 0 or equivalently f(y_eqx_eqp) = 0, while obviously satisfying g(y_eq x_eq p) = 0. To do that we use a first order approximation:","category":"page"},{"location":"Models/small/#","page":"Small Signal","title":"Small Signal","text":"beginalign\nleftbeginarrayc\n 0 \n  Deltadotx\n  endarrayright = underbraceleftbeginarray\n  g(y_eqx_eqp) \n   f(y_eqx_eqp) endarrayright_ = 0\n + Jy_eq x_eq p leftbeginarrayc\n Delta y \n  Delta x\n  endarrayright\n  endalign","category":"page"},{"location":"Models/small/#","page":"Small Signal","title":"Small Signal","text":"The first to note is that the jacobian matrix can be splitted in 4 blocks depending on the specific variables we are taking the partial derivatives:","category":"page"},{"location":"Models/small/#","page":"Small Signal","title":"Small Signal","text":"beginalign\nJy_eq x_eq p =\nleftbeginarraycc\n g_y  g_x \n f_y  f_x \n  endarrayright\nendalign","category":"page"},{"location":"Models/small/#","page":"Small Signal","title":"Small Signal","text":"For small signal analyses, we are interested in the stability of the differential states, while still considering that those need to evolve in the manifold defined by the linearized algebraic equations. Assuming that g_y is not singular (see chapter 7 of Federico Milano's book: \"Power System Modelling and Scripting\" or the following paper) we can eliminate the algebraic variables to obtain the reduced jacobian:","category":"page"},{"location":"Models/small/#","page":"Small Signal","title":"Small Signal","text":"beginalign\nJ_textred = f_x - f_y g_y^-1 g_x\nendalign","category":"page"},{"location":"Models/small/#","page":"Small Signal","title":"Small Signal","text":"that defines our reduced system for the differential variables","category":"page"},{"location":"Models/small/#","page":"Small Signal","title":"Small Signal","text":"beginalign\nDelta dotx = J_textred Delta x\nendalign","category":"page"},{"location":"Models/small/#","page":"Small Signal","title":"Small Signal","text":"on which we can compute its eigenvalues to analyze local stability.","category":"page"},{"location":"Models/small/#Automatic-Differentiation-1","page":"Small Signal","title":"Automatic Differentiation","text":"","category":"section"},{"location":"Models/small/#","page":"Small Signal","title":"Small Signal","text":"Once an equilibrium point is found, the complete jacobian of the non-linear system can be obtained using automatic differentiation in Julia. In particular, the package ForwardDiff.jl is used to obtain the jacobian of the non-linear algebraic system of equations. LITS.jl handles the resulting jacobian and reports the reduced jacobian and the corresponding eigenvalues and eigenvectors.","category":"page"},{"location":"Models/gens/#Generator-Models-1","page":"Generator","title":"Generator Models","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"Here we discuss the structure and models used to model generators in LITS.jl. Each generator is a data structure that is defined by the following components:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"Machine: That defines the stator electro-magnetic dynamics.\nShaft: That describes the rotor electro-mechanical dynamics.\nAutomatic Voltage Regulator: Electromotive dynamics to model an AVR controller.\nPower System Stabilizer: Control dynamics to define an stabilization signal for the AVR.\nPrime Mover and Turbine Governor: Thermo-mechanical dynamics and associated controllers.","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"The following figure summarizes the components of a generator and which variables they share:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"<img src=\"../../assets/gen_metamodel.png\" width=\"75%\"/>","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"⠀","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"Each generator is defined in its own dq reference frame. Let delta be the rotor angle of the generator. If v_r + jv_i = v_hangle theta defines the voltage in the bus in the network reference frame RI rotating at nominal frequency Omega_b, then the following equations (both are equivalent) can be used to convert between reference frames:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\nleft beginarrayc v_d  v_q endarray right =  left beginarrayc v_h sin(delta - theta)  v_h cos(delta - theta) endarray right  tag0a \nleft beginarrayc v_d  v_q endarray right = left beginarraycc sin(delta)  -cos(delta)  cos(delta)  sin(delta) endarray right left beginarrayc v_r  v_i endarray right tag0b\nendalign","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"Models are based from Federico Milano's book: \"Power System Modelling and Scripting\" and Prabha Kundur's book: \"Power System's Stability and Control\" and structures are defined in PowerSystems.jl abbreviated as PSY.","category":"page"},{"location":"Models/gens/#Machines-1","page":"Generator","title":"Machines","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"The machine component describes the stator-rotor electromagnetic dynamics.","category":"page"},{"location":"Models/gens/#Classical-Model-(Zero-Order)-[PSY.BaseMachine]-1","page":"Generator","title":"Classical Model (Zero Order) [PSY.BaseMachine]","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This is the classical order model that does not have differential equations in its machine model (delta and omega are defined in the shaft):","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\n  left beginarrayc i_d  i_q endarray right = left beginarraycc r_a  -x_d  x_d  r_a endarray right^-1  left beginarrayc -v_d  e_q - v_q endarray right tag1a\np_e approx tau_e = (v_q + r_a i_q)i_q + (v_d + r_ai_d)i_d tag1b\nendalign","category":"page"},{"location":"Models/gens/#One-d-One-q-Model-(2th-Order)-[PSY.OneDOneQMachine]-1","page":"Generator","title":"One d- One q- Model (2th Order) [PSY.OneDOneQMachine]","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This model includes two transient emf with their respective differential equations:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\ndote_q = frac1T_d0 left-e_q + (x_d-x_d)i_d + v_fright tag2a\ndote_d = frac1T_q0 left-e_d + (x_q-x_q)i_q right tag2b\n  left beginarrayc i_d  i_q endarray right = left beginarraycc r_a  -x_q  x_d  r_a endarray right^-1  left beginarrayc e_d-v_d  e_q - v_q endarray right tag2c\np_e approx tau_e = (v_q + r_a i_q)i_q + (v_d + r_ai_d)i_d tag2d\nendalign","category":"page"},{"location":"Models/gens/#Marconato-Machine-(6th-Order)-[PSY.MarconatoMachine]-1","page":"Generator","title":"Marconato Machine (6th Order) [PSY.MarconatoMachine]","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"The Marconato model defines 6 differential equations, two for stator fluxes and 4 for transient and subtransient emfs:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\ndotpsi_d = Omega_b(r_ai_d + omega psi_q + v_d) tag3a \ndotpsi_q = Omega_b(r_ai_q - omega psi_d + v_q) tag3b \ndote_q = frac1T_d0 left-e_q - (x_d-x_d-gamma_d)i_d + left(1- fracT_AAT_d0 right) v_fright tag3c\ndote_d = frac1T_q0 left-e_d + (x_q-x_q-gamma_q)i_q right tag3d\ndote_q = frac1T_d0 left-e_q + e_q - (x_d-x_d+gamma_d)i_d + fracT_AAT_d0v_f right tag3e \ndote_d = frac1T_q0 left-e_d + e_d + (x_q-x_q+gamma_q)i_q right tag3f \ni_d = frac1x_d (e_q - psi_d) tag3g \ni_q = frac1x_q (-e_d - psi_q) tag3h \ntau_e = psi_d i_q - psi_q i_d tag3i\nendalign","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"with","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign*\n  gamma_d = fracT_d0 x_dT_d0 x_d (x_d - x_d) \n  gamma_q = fracT_q0 x_qT_q0 x_q (x_q - x_q)\nendalign*","category":"page"},{"location":"Models/gens/#Simplified-Marconato-Machine-(4th-Order)-[PSY.SimpleMarconatoMachine]-1","page":"Generator","title":"Simplified Marconato Machine (4th Order) [PSY.SimpleMarconatoMachine]","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This model neglects the derivative of stator fluxes (dotpsi_d and  dotpsi_q) and assume that the rotor speed stays close to 1 pu (omegapsi_d=psi_d and omegapsi_q=psi_q) that allows to remove the stator fluxes variables from the Marconato model.","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\ndote_q = frac1T_d0 left-e_q - (x_d-x_d-gamma_d)i_d + left(1- fracT_AAT_d0 right) v_fright tag4a\ndote_d = frac1T_q0 left-e_d + (x_q-x_q-gamma_q)i_q right tag4b\ndote_q = frac1T_d0 left-e_q + e_q - (x_d-x_d+gamma_d)i_d + fracT_AAT_d0v_f right tag4c \ndote_d = frac1T_q0 left-e_d + e_d + (x_q-x_q+gamma_q)i_q right tag4d \nleft beginarrayc i_d  i_q endarray right = left beginarraycc r_a  -x_q  x_d  r_a endarray right^-1  left beginarrayc e_d-v_d  e_q - v_q endarray right tag4e\np_e approx tau_e = (v_q + r_a i_q)i_q + (v_d + r_ai_d)i_d tag4f\nendalign","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"with","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign*\n  gamma_d = fracT_d0 x_dT_d0 x_d (x_d - x_d) \n  gamma_q = fracT_q0 x_qT_q0 x_q (x_q - x_q)\nendalign*","category":"page"},{"location":"Models/gens/#Anderson-Fouad-Machine-(6th-Order)-[PSY.AndersonFouadMachine]-1","page":"Generator","title":"Anderson-Fouad Machine (6th Order) [PSY.AndersonFouadMachine]","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"The Anderson-Fouad model also defines 6 differential equations, two for stator fluxes and 4 for transient and subtransient emfs and is derived from the Marconato model by defining gamma_d approx gamma_q approx T_AA approx 0:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\ndotpsi_d = Omega_b(r_ai_d + omega psi_q + v_d) tag5a \ndotpsi_q = Omega_b(r_ai_q - omega psi_d + v_q) tag5b \ndote_q = frac1T_d0 left-e_q - (x_d-x_d)i_d + v_fright tag5c\ndote_d = frac1T_q0 left-e_d + (x_q-x_q)i_q right tag5d\ndote_q = frac1T_d0 left-e_q + e_q - (x_d-x_d)i_d right tag5e \ndote_d = frac1T_q0 left-e_d + e_d + (x_q-x_q)i_q right tag5f \ni_d = frac1x_d (e_q - psi_d) tag5g \ni_q = frac1x_q (-e_d - psi_q) tag5h \ntau_e = psi_d i_q - psi_q i_d tag5i\nendalign","category":"page"},{"location":"Models/gens/#Simplified-Anderson-Fouad-Machine-(4th-Order)-[PSY.SimpleAFMachine]-1","page":"Generator","title":"Simplified Anderson-Fouad Machine (4th Order) PSYSimpleAFMachine","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"Similar to the Simplified Marconato Model, this model neglects the derivative of stator fluxes (dotpsi_d and  dotpsi_q) and assume that the rotor speed stays close to 1 pu (omega psi_d = psi_d and omega psi_q = psi_q) that allows to remove the stator fluxes variables from the model:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\ndote_q = frac1T_d0 left-e_q - (x_d-x_d)i_d + v_fright tag6a\ndote_d = frac1T_q0 left-e_d + (x_q-x_q)i_q right tag6b\ndote_q = frac1T_d0 left-e_q + e_q - (x_d-x_d)i_d right tag6c \ndote_d = frac1T_q0 left-e_d + e_d + (x_q-x_q)i_q right tag6d \nleft beginarrayc i_d  i_q endarray right = left beginarraycc r_a  -x_q  x_d  r_a endarray right^-1  left beginarrayc e_d-v_d  e_q - v_q endarray right tag6e\np_e approx tau_e = (v_q + r_a i_q)i_q + (v_d + r_ai_d)i_d tag6f\nendalign","category":"page"},{"location":"Models/gens/#Rotor-Fluxes-Model-(5th-Order)-[PSY.FullMachine]-1","page":"Generator","title":"Rotor Fluxes Model (5th Order) [PSY.FullMachine]","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This models describes a machine model using 2 stator fluxes psi_d and psi_q, the rotor field flux psi_f, the d-axis damping psi_1d and only one q-axis damping circuit psi_1q:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\ndotpsi_d = Omega_b(r_a i_d + omega psi_q + v_d) tag7a \ndotpsi_q = Omega_b(r_ai_q - omega psi_d + v_q) tag7b \ndotpsi_f = -r_f i_f + v_f tag7c\ndotpsi_1d = -r_1di_1d tag7d\ndotpsi_1q = -r_1qi_1q tag7e \nleft beginarrayc i_d  i_f  i_1d endarray right = left beginarrayccc -L_d  -L_ad  L_ad  -L_ad  L_ff  L_f1d  -L_ad  L_f1d  L_1d endarray right^-1  left beginarrayc psi_d  psi_f   psi_1d endarray right tag7f\nleft beginarrayc i_q  i_1q  endarray right = left beginarrayccc -L_q  L_aq   -L_aq  L_1q endarray right^-1  left beginarrayc psi_q  psi_1q  endarray right tag7g\ntau_e = psi_d i_q - psi_q i_d tag7h\nendalign","category":"page"},{"location":"Models/gens/#Shafts-1","page":"Generator","title":"Shafts","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"The shaft component defines the rotating mass of the synchronous generator.","category":"page"},{"location":"Models/gens/#Rotor-Mass-Shaft-[PSY.SingleMass]-1","page":"Generator","title":"Rotor Mass Shaft [PSY.SingleMass]","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This is the standard model, on which one single mass (typically the rotor) is used to model the entire inertia of the synchronous generator. Each generator's rotating frame use a reference frequency omega_s, that typically is the synchronous one (i.e. omega_s = 10). The model defines two differential equations for the rotor angle delta and the rotor speed omega:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\ndotdelta = Omega_b(omega - omega_s) tag8a \ndotomega = frac12H(tau_m - tau_e - D(omega-omega_s)) tag8b\nendalign","category":"page"},{"location":"Models/gens/#Five-Mass-Shaft-[PSY.FiveMassShaft]-1","page":"Generator","title":"Five-Mass Shaft [PSY.FiveMassShaft]","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This model describes model connecting a high-pressure (hp) steam turbine, intermediate-pressure (ip) steam turbine, low-pressure (lp) steam pressure, rotor and exciter (ex) connected in series (in that order) in the same shaft using a spring-mass model:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\ndotdelta = Omega_b(omega - omega_s) tag9a \ndotomega = frac12H left- tau_e - D(omega-omega_s)) - D_34 (omega-omega_lp) - D_45(omega-omega_ex) + K_lp(delta_lp-delta) +K_ex(delta_ex-delta) right tag9b \ndotdelta_hp = Omega_b(omega_hp - omega_s) tag9c \ndotomega_hp = frac12H_hp left tau_m - D_hp(omega_hp-omega_s) - D_12(omega_hp - omega_ip) + K_hp(delta_ip - delta_hp) right tag9d \ndotdelta_ip = Omega_b(omega_ip - omega_s) tag9e \ndotomega_ip = frac12H_ip left- D_ip(omega_ip-omega_s) - D_12(omega_ip - omega_hp) -D_23(omega_ip - omega_lp ) + K_hp(delta_hp - delta_ip) + K_ip(delta_lp-delta_ip) right tag9f \ndotdelta_lp = Omega_b(omega_lp-omega_s) tag9g \ndotomega_lp = frac12H_lp left - D_lp(omega_lp-omega_s) - D_23(omega_lp - omega_ip) -D_34(omega_lp - omega ) + K_ip(delta_ip - delta_lp) + K_lp(delta-delta_lp) right tag9h \ndotdelta_ex = Omega_b(omega_ex-omega_s) tag9i \ndotomega_ex = frac12H_ex left - D_ex(omega_ex-omega_s) - D_45(omega_ex - omega) + K_ex(delta - delta_ex) right tag9j\nendalign","category":"page"},{"location":"Models/gens/#Automatic-Voltage-Regulators-(AVR)-1","page":"Generator","title":"Automatic Voltage Regulators (AVR)","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"AVR are used to determine the voltage in the field winding v_f in the model.","category":"page"},{"location":"Models/gens/#Fixed-AVR-[PSY.AVRFixed]-1","page":"Generator","title":"Fixed AVR [PSY.AVRFixed]","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This is a simple model that set the field voltage to be equal to a desired constant value v_f = v_textfix.","category":"page"},{"location":"Models/gens/#Simple-AVR-[PSY.AVRSimple]-1","page":"Generator","title":"Simple AVR [PSY.AVRSimple]","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This depicts the most basic AVR, on which the field voltage is an integrator over the difference of the measured voltage and a reference:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\ndotv_f = K_v(v_textref - v_h) tag10a\nendalign","category":"page"},{"location":"Models/gens/#AVR-Type-I-[PSY.AVRTypeI]-1","page":"Generator","title":"AVR Type I [PSY.AVRTypeI]","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This AVR is a simplified version of the IEEE DC1 AVR model:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\ndotv_f = -frac1T_e left V_f(K_e + S_e(v_f))-v_r1 right tag11a \ndotv_r1 = frac1T_a left K_aleft(v_textref - v_m - v_r2 - fracK_fT_fv_fright) - v_r1 right   tag11b \ndotv_r2 =  -frac1T_f left fracK_fT_fv_f + v_r2 right  tag11c \ndotv_m = frac1T_r (v_h - v_m) tag11d\nendalign","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"with the ceiling function:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign*\nS_e(v_f) = A_e exp(B_ev_f)\nendalign*","category":"page"},{"location":"Models/gens/#AVR-Type-II-[PSY.AVRTypeII]-1","page":"Generator","title":"AVR Type II [PSY.AVRTypeII]","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This model represents a static exciter with higher gains and faster response than the Type I:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\ndotv_f = -frac1T_e left V_f(1 + S_e(v_f))-v_r right tag12a \ndotv_r1 = frac1T_1 left K_0left(1 - fracT_2T_1 right)(v_textref - v_m) - v_r1  right tag12b \ndotv_r2 =  frac1K_0 T_3 left left( 1 - fracT_4T_3 right) left( v_r1 + K_0fracT_2T_1(v_textref - v_m)right) - K_0 v_r2 right  tag12c \ndotv_m = frac1T_r (v_h - v_m) tag12d\nendalign","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"with","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign*\nv_r = K_0v_r2 + fracT_4T_3 left( v_r1 + K_0fracT_2T_1(v_textref - v_m)right) \nS_e(v_f) = A_e exp(B_ev_f)\nendalign*","category":"page"},{"location":"Models/gens/#Power-System-Stabilizers-(PSS)-1","page":"Generator","title":"Power System Stabilizers (PSS)","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"PSS are used to add an additional signal v_s to the field voltage: v_f = v_f^textavr + v_s.","category":"page"},{"location":"Models/gens/#Fixed-PSS-[PSY.PSSFixed]-1","page":"Generator","title":"Fixed PSS [PSY.PSSFixed]","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This is a simple model that set the stabilization signal to be equal to a desired constant value v_s = v_s^textfix. The absence of PSS can be modelled using this component with v_s^textfix = 0.","category":"page"},{"location":"Models/gens/#Simple-PSS-[PSY.PSSSimple]-1","page":"Generator","title":"Simple PSS [PSY.PSSSimple]","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This is the most basic PSS that can be implemented, on which the stabilization signal is simply a proportional controller over the frequency and electrical power:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\nv_s = K_omega(omega - omega_s) + K_p(omega tau_e - P_textref) tag12a\nendalign","category":"page"},{"location":"Models/gens/#Prime-Movers-and-Turbine-Governors-(TG)-1","page":"Generator","title":"Prime Movers and Turbine Governors (TG)","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This section describes how mechanical power is modified to provide primary frequency control with synchronous generators. It is assumed that tau_textref = P_textref since they are decided at nominal frequency omega = 1.","category":"page"},{"location":"Models/gens/#Fixed-TG-[PSY.TGFixed]-1","page":"Generator","title":"Fixed TG [PSY.TGFixed]","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This a simple model that set the mechanical torque to be equal to a proportion of the desired reference tau_m = eta P_textref. To set the mechanical torque to be equal to the desired power, the value of eta is set to 1.","category":"page"},{"location":"Models/gens/#TG-Type-I-[PSY.TGTypeI]-1","page":"Generator","title":"TG Type I [PSY.TGTypeI]","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This turbine governor is described by a droop controller and a low-pass filter to model the governor and two lead-lag blocks to model the servo and reheat of the turbine governor.","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\ndotx_g1 = frac1T_s(p_textin - x_g1) tag13a \ndotx_g2 = frac1T_c left left(1- fract_3T_cright)x_g1 - x_g2 right tag13b \ndotx_g3 = frac1T_5 leftleft(1 - fracT_4T_5right)left(x_g2 + fracT_3T_cx_g1right) - x_g3  right tag13c \ntau_m = x_g3 + fracT_4T_5left(x_g2 + fracT_3T_cx_g1right) tag13d\nendalign","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"with","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign*\np_textin = P_textref + frac1R(omega_s - 1)\nendalign*","category":"page"},{"location":"Models/gens/#TG-Type-II-[PSY.TGTypeII]-1","page":"Generator","title":"TG Type II [PSY.TGTypeII]","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This turbine governor is a simplified model of the Type I.","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\ndotx_g = frac1T_2leftfrac1Rleft(1 - fracT_1T_2right) (omega_s - omega) - x_gright tag14a \ntau_m = P_textref + frac1RfracT_1T_2(omega_s - omega) tag14b\nendalign","category":"page"},{"location":"Models/gens/#Reference-1","page":"Generator","title":"Reference","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"For constructors check the API on PowerSystems.jl documentation","category":"page"},{"location":"Examples/example_OMIB/#Tutorial:-One-Machine-against-Infinite-Bus-(OMIB)-1","page":"Tutorial 1: OMIB","title":"Tutorial: One Machine against Infinite Bus (OMIB)","text":"","category":"section"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"This tutorial will introduce you to the functionality of LITS for running Power System Simulations. Note that this tutorial is for LITS 0.3.0. Future versions will have dedicated functions to find an equilibrium point using a Power Flow method without relying in a guess of the initial condition to run a non-linear solver.","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"This tutorial presents a simulation of a two-bus system, with an infinite bus (represented as a voltage source behind an impedance) at bus 1 and a classic machine on bus 2. The perturbation will be the trip of one of the two circuits (doubling its resistance and impedance) of the line that connects both buses.","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"This tutorial can be found on LITS/Examples repository.","category":"page"},{"location":"Examples/example_OMIB/#Step-1:-Package-Initialization-1","page":"Tutorial 1: OMIB","title":"Step 1: Package Initialization","text":"","category":"section"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"The first step consists in initialize all packages that will be used to run the simulation. All the necessary packages are listed:","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"using LITS\nusing PowerSystems\nusing Sundials\nconst PSY = PowerSystems","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"PowerSystems is used to properly define the data structure, while Sundials is used to fsolve the problem defined in LITS. Finally we call use can call PowerSystems functions using the PSY abbreviation.","category":"page"},{"location":"Examples/example_OMIB/#Step-2:-Data-creation-1","page":"Tutorial 1: OMIB","title":"Step 2: Data creation","text":"","category":"section"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"Next we need to define the different elements required to run a simulation. To run a simulation, it is required to define a PSY.System that requires the following components:","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"Vector of PSY.Bus elements, that define all the buses in the network.\nVector of PSY.Branch elements, that define all the branches elements (that connect two buses) in the network.\nVector of PSY.DynamicInjection elements, that define all the devices connected to buses that can inject (or withdraw) current, while also defining differential equations to model its dynamics. These include generators and inverters.\nVector of PSY.PowerLoad elements, that define all the loads connected to buses that can withdraw current, without defining any differential equation. Note that LITS will convert ConstantPower loads to RLC loads for transient simulations.\nVector of PSY.Source elements, that define source components behind a reactance that can inject or withdraw current, without defining any differential equation.\nThe base of power used to define per unit values, in MVA as a Float64 value.\nThe base frequency used in the system, in Hz as a Float64 value.\n(Optional) Selecting which of the PSY.Lines (of the PSY.Branch vector) elements must be modeled of DynamicLines elements, that can be used to model lines with differential equations.","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"To start we will define the data structures for the network.","category":"page"},{"location":"Examples/example_OMIB/#Buses-and-Branches-1","page":"Tutorial 1: OMIB","title":"Buses and Branches","text":"","category":"section"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"As mentioned earlier, we require to create a Vector of PSY.Bus to define the buses in the network. Currently, some of the parameters are not used in LITS, but will be used once the initialization procedure is implemented (such as voltage limits or the requested bus voltage).","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"#Define the vector of buses\nnodes_OMIB = [\n    PSY.Bus(\n        1, #number\n        \"Bus 1\", #Name\n        \"REF\", #BusType (REF, PV, PQ)\n        0, #Angle in radians\n        1.05, #Voltage in pu\n        (min = 0.94, max = 1.06), #Voltage limits in pu\n        69, #Base voltage in kV\n    ),\n    PSY.Bus(2, \"Bus 2\", \"PV\", 0, 1.0, (min = 0.94, max = 1.06), 69),\n]","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"Note that two buses are defined in the vector nodes_case1. It is important that the bus numbers are ordered from 1 to n, since that structure will be used to construct the vector of variables. Future versions of LITS will allow to relax this assumption. Similarly, to define the branches (that also has some parameters that are currently not used, such as the rate and angle limits):","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"#Define the vector of branches\nbranch_OMIB = [PSY.Line(\n    \"Line1\", #name\n    true, #available\n    0.0, #active power flow initial condition (from-to)\n    0.0, #reactive power flow initial condition (from-to)\n    Arc(from = nodes_OMIB[1], to = nodes_OMIB[2]), #Connection between buses\n    0.01, #resistance in pu\n    0.05, #reactance in pu\n    (from = 0.0, to = 0.0), #susceptance in pu\n    18.046, #rate in MW\n    1.04, #angle limits (-min and max)\n)]","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"Since we are interested in creating a fault that trips one of the two circuits of the line, we will create an additional Vector of branches with doubled impedance:","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"#Define the vector of branches under the fault\nbranch_OMIB_fault = [PSY.Line(\n    \"Line1\", #name\n    true, #available\n    0.0, #active power flow initial condition (from-to)\n    0.0, #reactive power flow initial condition (from-to)\n    Arc(from = nodes_OMIB[1], to = nodes_OMIB[2]), #Connection between buses\n    0.02, #resistance in pu\n    0.1, #reactance in pu\n    (from = 0.0, to = 0.0), #susceptance in pu\n    18.046, #rate in MW\n    1.04, #angle limits (-min and max)\n)]","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"Note that the resistance and reactance is doubled in comparison to the system without fault.","category":"page"},{"location":"Examples/example_OMIB/#Injection-devices-1","page":"Tutorial 1: OMIB","title":"Injection devices","text":"","category":"section"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"Secondly, we will define devices that can inject/withdraw electric current directly without defining differential equations. In this case we include a load and the voltage source that model the infinite bus.","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"loads_OMIB = [PSY.PowerLoad(\n    \"LBus1\", #name\n    true, #availability\n    nodes_OMIB[2], #bus\n    PSY.LoadModels.ConstantPower, #type\n    0.3, #P\n    0.01, #Q\n    0.3, #P_max\n    0.01, #Q_max\n)]\n\ninf_gen_OMIB = [PSY.Source(\n    \"InfBus\", #name\n    true, #availability\n    nodes_OMIB[1], #bus\n    1.05, #VR\n    0.0, #VI\n    0.000005, #Xth\n)]","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"Note that loads are assumed as constant power for power flow purposes, but for dynamic simulations are converted to impedance loads assuming nominal voltage equals to 1 pu.","category":"page"},{"location":"Examples/example_OMIB/#Dynamic-Injection-devices-1","page":"Tutorial 1: OMIB","title":"Dynamic Injection devices","text":"","category":"section"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"Third, we define the Vector of PSY.DynamicInjection elements. In this case, we require to define a generator located in bus 2. For that purpose, we need to define its machine, shaft, automatic voltage regulator (AVR), turbine governor (TG) and power system stabilizer (PSS):","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"### Machine ###\nmachine_OMIB = PSY.BaseMachine(\n    0.0, #R\n    0.2995, #Xd_p\n    0.7087, #eq_p\n    100.0,\n)  #MVABase\n\n######## Shaft Data #########\n\n### Shaft for Case 1 ###\nshaft_OMIB = PSY.SingleMass(\n    3.148, #H\n    2.0, #D\n)\n\n########  AVR Data #########\navr_OMIB = AVRFixed(0.0) #Vf not applicable in Classic Machines\n\n######## TG Data #########\n### No TG ###\ntg_OMIB = TGFixed(1.0) #No TG: Efficiency = 1.0\n\n######## PSS Data #########\n### No PSS ###\npss_OMIB = PSSFixed(0.0) #No PSS without AVR\n\n### Constructing the Generator ###\ngen_OMIB = PSY.DynamicGenerator(\n    1, #Number\n    \"OMIB_Gen\", #name\n    nodes_OMIB[2], #bus\n    1.0, #ω_ref\n    1.0, #V_ref\n    0.5, #P_ref\n    0.0, #Q_ref: Not used for standard machines (only for PQ gens)\n    machine_OMIB, #machine\n    shaft_OMIB, #shaft\n    avr_OMIB, #avr\n    tg_OMIB, #tg\n    pss_OMIB, #pss\n)","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"Note that a generator is defined by its 5 components, while also defining its reference for frequency, voltage and power. The reactive power reference must be defined but is not used for standard machines, since is only used for PQ generators, that will be implemented in future versions of LITS.","category":"page"},{"location":"Examples/example_OMIB/#Defining-the-Dynamic-System-1","page":"Tutorial 1: OMIB","title":"Defining the Dynamic System","text":"","category":"section"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"Finally, with all the components properly constructed we define the dynamic system:","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"#Create the system\nsys = PSY.System(\n      100.0, #Base MVA\n      frequency = 60.0, #Nominal frequency in Hz\n)\n\n#Add the buses to the system\nfor bus in nodes_OMIB\n    PSY.add_component!(sys, bus)\nend\n\n#Add the branches to the system\nfor br in branch_OMIB\n    PSY.add_component!(sys, br)\nend\n\n#Add the loads to the system\nfor load in loads_OMIB\n    PSY.add_component!(sys, load)\nend\n\n#Add the sources (infinite gens) to the system\nfor source in inf_gen_OMIB\n    PSY.add_component!(sys, source)\nend\n\n#Add the generator\nPSY.add_component!(sys, gen_OMIB)","category":"page"},{"location":"Examples/example_OMIB/#Step-3:-Build-the-simulation-and-initializing-the-problem-1","page":"Tutorial 1: OMIB","title":"Step 3: Build the simulation and initializing the problem","text":"","category":"section"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"The next step is to create the simulation structure. This will create the indexing of our system that will be used to formulate the differential-algebraic system of equations. To do so, it is required to specify the perturbation that will occur in the system. LITS support two types of perturbations:","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"Three Phase Fault\nChange in Reference Parameter","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"In here, he will use a Three Phase Fault, that is modeled by modifying the admittance matrix of the system. To do so we create a ThreePhaseFault perturbation as follows:","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"#Obtain the Ybus of the faulted system\nYbus_fault = PSY.Ybus(\n    branch_OMIB_fault, #fault set of lines\n    nodes_OMIB, #set of buses\n)[:,:]\n\n#Construct the perturbation\nperturbation_Ybus = ThreePhaseFault(\n    1.0, #change will occur at t = 1.0s\n    Ybus_fault, #new Ybus\n)","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"With this, we are ready to create our simulation structure. We will skip solving for initial conditions to discuss about indexing. To construct our simulation we use:","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"#Time span of our simulation\ntspan = (0.0, 30.0)\n\n#Define Simulation\nsim = Simulation(\n    sys, #system\n    tspan, #time span\n    perturbation_Ybus, #Type of perturbation\n    initialize_simulation = false #keyword argument to not find initial conditions.\n)","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"This will create the simulation structure that will be used to run the transient simulation and will modify the system to include the indexing. LITS will have the following structure for the vector of variables:","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"x = leftbeginarrayc v_r  v_i  z endarrayright","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"on which v_r is the vector of real voltages of all buses, v_i is the vector of imaginary voltages of all buses and z is the rest of states defined by the dynamic devices. Then, the length of the vector of variables will 2n + textlen(z), where n is the number of buses in the system. The indexing of the states can be found using:","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"ext = PSY.get_ext(sim.system) #Obtain ext information of the system\next[\"global_index\"] #Showcase the global indexing of z","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"In this system, delta of the generator is state 5 and omega is state 6 (since the first 4 states are the bus voltages). In addition, ext[\"lits_counts\"] has information on the total variables and total states (differential variables).","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"The next step consists in finding an initial condition for the states. In this case simply running","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"#Define Simulation\nsim = Simulation(\n    sys, #system\n    tspan, #time span\n    perturbation_Ybus, #Type of perturbation\n)","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"will correctly initialize the system. If no initial guess is provided, the system will use a flat start guess, assuming that all real voltages are equal to one, while imaginary voltages are equal to zero. Differential variables (states) will be guessed as zero too. The initial values can be obtained using sim.x0_init. However, for most systems if a bad initial guess is used, the non-linear solver may fail in correctly initializing the system. For such purposes, an initial guess can be provided to the simulation as follows:","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"#Initial guess\nx0_guess = [\n    1.0, #VR_1\n    1.0, #VR_2\n    0.0, #VI_1\n    0.0, #VI_2\n    0.2, #δ\n    1.0, #ω\n]\n\n#Define Simulation\nsim = Simulation(\n    sys, #system\n    tspan, #time span\n    perturbation_Ybus, #Type of perturbation\n    initial_guess = x0_guess, #initial guess\n)\n\n#Check the initial condition\nsim.x0_init","category":"page"},{"location":"Examples/example_OMIB/#Step-4:-Run-the-Simulation-1","page":"Tutorial 1: OMIB","title":"Step 4: Run the Simulation","text":"","category":"section"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"Finally, to run the simulation we simply use:","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"#Solve problem\nrun_simulation!(sim, #simulation structure\n                IDA(), #Sundials DAE Solver\n                dtmax=0.02); #Arguments: Maximum timestep allowed","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"In some cases, the dynamic time step used for the simulation may fail. In such case, the keyword argument dtmax can be used to limit the maximum time step allowed for the simulation.","category":"page"},{"location":"Examples/example_OMIB/#Step-5:-Exploring-the-solution-1","page":"Tutorial 1: OMIB","title":"Step 5: Exploring the solution","text":"","category":"section"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"After running the simulation, our simulation structure sim will have the solution. For that sim.solution can be used to explore the solution structure. In this case sim.solution.t returns the vector of time, while sim.solution.u return the array of states. In addition, LITS have two functions to obtain different states of the solution:","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"get_state_series(sim, (\"OMIB_Gen\", :δ)): can be used to obtain the solution as a tuple of time and the required state. In this case, we are obtaining the rotor angle :δ of the generator named \"OMIB_Gen\".\nget_voltagemag_series(sim, 2): can be used to obtain the voltage magnitude as a tuple of time and voltage. In this case, we are obtaining the voltage magnitude at bus 2 (where the generator is located).","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"using Plots\nangle = get_state_series(sim, (\"OMIB_Gen\", :δ))\nplot(angle, xlabel=\"time\", ylabel=\"rotor angle [rad]\", label=\"rotor angle\")\n\nvolt = get_voltagemag_series(sim, 2)\nplot(volt, xlabel=\"time\", ylabel=\"Voltage [pu]\", label=\"V_2\")","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"<img src=\"../../assets/rotor_angle_OMIB.png\" width=\"75%\"/>","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"⠀","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"<img src=\"../../assets/voltage_OMIB.png\" width=\"75%\"/>","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"⠀","category":"page"},{"location":"Examples/example_OMIB/#Optional:-Small-Signal-Analysis-1","page":"Tutorial 1: OMIB","title":"Optional: Small Signal Analysis","text":"","category":"section"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"LITS 0.3.0 uses automatic differentiation to compute the reduced Jacobian of the system for the differential states. This can be used to analyze the local stability of the linearized system.","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"small_sig = small_signal_analysis(sim)","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"The small_sig result can report the reduced jacobian for delta and omega, and can also be used to report the eigenvalues of the reduced linearized system.","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"small_sig.reduced_jacobian\n\nsmall_sig.eigenvalues","category":"page"},{"location":"api/LITS/#LITS-1","page":"LITS","title":"LITS","text":"","category":"section"},{"location":"api/LITS/#","page":"LITS","title":"LITS","text":"CurrentModule = LITS\nDocTestSetup  = quote\n    using LITS\nend","category":"page"},{"location":"api/LITS/#","page":"LITS","title":"LITS","text":"API documentation","category":"page"},{"location":"api/LITS/#","page":"LITS","title":"LITS","text":"Pages = [\"LITS.md\"]","category":"page"},{"location":"api/LITS/#Index-1","page":"LITS","title":"Index","text":"","category":"section"},{"location":"api/LITS/#","page":"LITS","title":"LITS","text":"Pages = [\"LITS.md\"]","category":"page"},{"location":"api/LITS/#Exported-1","page":"LITS","title":"Exported","text":"","category":"section"},{"location":"api/LITS/#","page":"LITS","title":"LITS","text":"Modules = [LITS]\nPrivate = false","category":"page"},{"location":"api/LITS/#LITS.get_voltagemag_series-Tuple{Simulation,Int64}","page":"LITS","title":"LITS.get_voltagemag_series","text":"Function to obtain the voltage magnitude series out of the DAE Solution. It receives the solution, the dynamical system and the bus number.\n\n\n\n\n\n","category":"method"},{"location":"api/LITS/#LITS.print_init_states-Tuple{Simulation}","page":"LITS","title":"LITS.print_init_states","text":"Function to print initial states. It receives the vector of initial states and the dynamical system.\n\n\n\n\n\n","category":"method"},{"location":"api/LITS/#Internal-1","page":"LITS","title":"Internal","text":"","category":"section"},{"location":"api/LITS/#","page":"LITS","title":"LITS","text":"Modules = [LITS]\nPublic = false","category":"page"},{"location":"api/LITS/#InfrastructureSystems.get_forecasts-Tuple{DynamicLine}","page":"LITS","title":"InfrastructureSystems.get_forecasts","text":"Get Line _forecasts.\n\n\n\n\n\n","category":"method"},{"location":"api/LITS/#InfrastructureSystems.get_name-Tuple{DynamicLine}","page":"LITS","title":"InfrastructureSystems.get_name","text":"Get Line name.\n\n\n\n\n\n","category":"method"},{"location":"api/LITS/#LITS.kirchoff_laws-NTuple{6,Any}","page":"LITS","title":"LITS.kirchoff_laws","text":"Kirchoff law for buses.\nI_gen_r[j]: Real current injection from all generators connected at bus j.\n            It is zero if no generator is connected at bus j.\nI_gen_i[j]: Real current injection from all generators connected at bus j.\n            It is zero if no generator is connected at bus j.\n\n\n\n\n\n","category":"method"},{"location":"api/LITS/#PowerSystems.get_activepower_flow-Tuple{DynamicLine}","page":"LITS","title":"PowerSystems.get_activepower_flow","text":"Get Line activepower_flow.\n\n\n\n\n\n","category":"method"},{"location":"api/LITS/#PowerSystems.get_anglelimits-Tuple{DynamicLine}","page":"LITS","title":"PowerSystems.get_anglelimits","text":"Get Line anglelimits.\n\n\n\n\n\n","category":"method"},{"location":"api/LITS/#PowerSystems.get_arc-Tuple{DynamicLine}","page":"LITS","title":"PowerSystems.get_arc","text":"Get Line arc.\n\n\n\n\n\n","category":"method"},{"location":"api/LITS/#PowerSystems.get_available-Tuple{DynamicLine}","page":"LITS","title":"PowerSystems.get_available","text":"Get Line available.\n\n\n\n\n\n","category":"method"},{"location":"api/LITS/#PowerSystems.get_b-Tuple{DynamicLine}","page":"LITS","title":"PowerSystems.get_b","text":"Get Line b.\n\n\n\n\n\n","category":"method"},{"location":"api/LITS/#PowerSystems.get_ext-Tuple{DynamicLine}","page":"LITS","title":"PowerSystems.get_ext","text":"Get Line ext.\n\n\n\n\n\n","category":"method"},{"location":"api/LITS/#PowerSystems.get_internal-Tuple{DynamicLine}","page":"LITS","title":"PowerSystems.get_internal","text":"Get Line internal.\n\n\n\n\n\n","category":"method"},{"location":"api/LITS/#PowerSystems.get_r-Tuple{DynamicLine}","page":"LITS","title":"PowerSystems.get_r","text":"Get Line r.\n\n\n\n\n\n","category":"method"},{"location":"api/LITS/#PowerSystems.get_rate-Tuple{DynamicLine}","page":"LITS","title":"PowerSystems.get_rate","text":"Get Line rate.\n\n\n\n\n\n","category":"method"},{"location":"api/LITS/#PowerSystems.get_reactivepower_flow-Tuple{DynamicLine}","page":"LITS","title":"PowerSystems.get_reactivepower_flow","text":"Get Line reactivepower_flow.\n\n\n\n\n\n","category":"method"},{"location":"api/LITS/#PowerSystems.get_services-Tuple{DynamicLine}","page":"LITS","title":"PowerSystems.get_services","text":"Get Line services.\n\n\n\n\n\n","category":"method"},{"location":"api/LITS/#PowerSystems.get_x-Tuple{DynamicLine}","page":"LITS","title":"PowerSystems.get_x","text":"Get Line x.\n\n\n\n\n\n","category":"method"},{"location":"Examples/example_lines/#Tutorial:-Dynamic-Lines-1","page":"Tutorial 2: Dynamic Lines","title":"Tutorial: Dynamic Lines","text":"","category":"section"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"This tutorial will introduce an example of considering dynamic lines in LITS. Note that this tutorial is for LITS 0.3.0. Future versions will have dedicated functions to find an equilibrium point using a Power Flow method without relying in a guess of the initial condition to run a non-linear solver.","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"This tutorial presents a simulation of a three-bus system, with an infinite bus (represented as a voltage source behind an impedance) at bus 1, a one d- one q- machine on bus 2 and an inverter of 19 states, as a virtual synchronous machine at bus 3. The perturbation will be the trip of two of the three circuits (triplicating its resistance and impedance) of the line that connects bus 1 and bus 3. This case also consider a dynamic line model for connection between buses 2 and 3.","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"It is recommended to check Tutorial 1: OMIB first, since that includes more details and explanations on all definitions and functions.","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"This tutorial can be found on LITS/Examples repository.","category":"page"},{"location":"Examples/example_lines/#Step-1:-Package-Initialization-1","page":"Tutorial 2: Dynamic Lines","title":"Step 1: Package Initialization","text":"","category":"section"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"using LITS\nusing PowerSystems\nusing Sundials\nconst PSY = PowerSystems","category":"page"},{"location":"Examples/example_lines/#Step-2:-Data-creation-1","page":"Tutorial 2: Dynamic Lines","title":"Step 2: Data creation","text":"","category":"section"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"To start we will define the data structures for the network.","category":"page"},{"location":"Examples/example_lines/#Buses-and-Branches-1","page":"Tutorial 2: Dynamic Lines","title":"Buses and Branches","text":"","category":"section"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"nodes_case9 = [\n    PSY.Bus(1, \"Bus 1\", \"REF\", 0, 1.02, (min = 0.94, max = 1.06), 138),\n    PSY.Bus(2, \"Bus 2\", \"PV\", 0, 1.00, (min = 0.94, max = 1.06), 138),\n    PSY.Bus(3, \"Bus 3\", \"PQ\", 0, 1.00, (min = 0.94, max = 1.06), 138),\n]\n\nbranch_case9 = [\n    PSY.Line(\n        \"Line1\",\n        true,\n        0.0,\n        0.0,\n        Arc(from = nodes_case9[1], to = nodes_case9[3]),\n        0.01,\n        0.12,\n        (from = 0.1, to = 0.1),\n        100,\n        1.04,\n    ),\n    PSY.Line(\n        \"Line2\",\n        true,\n        0.0,\n        0.0,\n        Arc(from = nodes_case9[1], to = nodes_case9[2]),\n        0.01,\n        0.12,\n        (from = 0.1, to = 0.1),\n        100,\n        1.04,\n    ),\n    PSY.Line(\n        \"Line3\",\n        true,\n        0.0,\n        0.0,\n        Arc(from = nodes_case9[2], to = nodes_case9[3]),\n        0.02,\n        0.9,\n        (from = 0.5, to = 0.5),\n        100,\n        1.04,\n    ),\n]\n\n#Trip of Line 1. Triplicates its impedance\nbranch_case9_fault = [\n    PSY.Line(\n        \"Line1\",\n        true,\n        0.0,\n        0.0,\n        Arc(from = nodes_case9[1], to = nodes_case9[3]),\n        0.03,\n        0.36,\n        (from = 0.03, to = 0.03),\n        100,\n        1.04,\n    ),\n    PSY.Line(\n        \"Line2\",\n        true,\n        0.0,\n        0.0,\n        Arc(from = nodes_case9[1], to = nodes_case9[2]),\n        0.01,\n        0.12,\n        (from = 0.1, to = 0.1),\n        100,\n        1.04,\n    ),\n    PSY.Line(\n        \"Line3\",\n        true,\n        0.0,\n        0.0,\n        Arc(from = nodes_case9[2], to = nodes_case9[3]),\n        0.02,\n        0.9,\n        (from = 0.5, to = 0.5),\n        100,\n        1.04,\n    ),\n];","category":"page"},{"location":"Examples/example_lines/#Injection-devices-1","page":"Tutorial 2: Dynamic Lines","title":"Injection devices","text":"","category":"section"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"loads_case9 = [\n    PowerLoad(\"Bus1\", true, nodes_case9[1], PSY.LoadModels.ConstantPower, 0.5, 0.1, 1.5, 0.8),\n    PowerLoad(\"Bus2\", true, nodes_case9[2], PSY.LoadModels.ConstantPower, 1.0, 0.3, 1.5, 0.8),\n    PowerLoad(\"Bus3\", true, nodes_case9[3], PSY.LoadModels.ConstantPower, 0.3, 0.1, 0.5, 0.3),\n]\n\ninf_gen_case9 = [PSY.Source(\n    \"InfBus\", #name\n    true, #availability\n    nodes_case9[1],#bus\n    1.00, #VR\n    0.0, #VI\n    0.000005,  #Xth\n)]","category":"page"},{"location":"Examples/example_lines/#Dynamic-injection-devices-1","page":"Tutorial 2: Dynamic Lines","title":"Dynamic injection devices","text":"","category":"section"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"First we define our generator data:","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"######## Machine Data #########\n\n### Case 2: 4th Order Model with AVR (3-bus case) ###\ncase9_machine = PSY.OneDOneQMachine(\n    0.0, #R\n    1.3125, #Xd\n    1.2578, #Xq\n    0.1813, #Xd_p\n    0.25, #Xq_p\n    5.89, #Td0_p\n    0.6, #Tq0_p\n    100.0,\n)   #MVABase\n\n######## Shaft Data #########\n\n### Shafts for Gen ###\ncase9_shaft = PSY.SingleMass(\n    3.01, #H (M = 6.02 -> H = M/2)\n    0.0,\n) #D\n\n######## PSS Data #########\ncases_no_pss = PSY.PSSFixed(0.0)\n\n######## TG Data #########\n\n### No TG for Cases 1, 2, 3, 4 ###\ncase9_no_tg = PSY.TGFixed(1.0) #eff\n\n########  AVR Data #########\n### AVRs for Case 2, 3, 4 and 5 ###\ncase9_avr = PSY.AVRTypeI(\n    20.0, #Ka - Gain\n    0.01, #Ke\n    0.063, #Kf\n    0.2, #Ta\n    0.314, #Te\n    0.35, #Tf\n    0.001, #Tr\n    5.0, #Vrmax\n    -5.0, #Vrmin\n    0.0039, #Ae - 1st ceiling coefficient\n    1.555,\n) #Be - 2nd ceiling coefficient\n\n### Case 7 Generators ###\ncase9_gen = PSY.DynamicGenerator(\n    1, #Number\n    \"Case9Gen\",\n    nodes_case9[2], #bus\n    1.0, # ω_ref,\n    1.0124, #V_ref\n    0.6, #P_ref\n    0.0, #Q_ref\n    case9_machine, #machine\n    case9_shaft, #shaft\n    case9_avr, #avr\n    case9_no_tg, #tg\n    cases_no_pss, #pss\n);","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"and for the inverter:","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"converter = PSY.AvgCnvFixedDC(\n    138.0, #Rated Voltage\n    100.0,\n) #Rated MVA\n\ndc_source = PSY.FixedDCSource(1500.0) #Not in the original data, guessed.\n\nfilt = PSY.LCLFilter(\n    0.08, #Series inductance lf in pu\n    0.003, #Series resitance rf in pu\n    0.074, #Shunt capacitance cf in pu\n    0.2, #Series reactance rg to grid connection (#Step up transformer or similar)\n    0.01,\n) #Series resistance lg to grid connection (#Step up transformer or similar)\n\npll = PSY.PLL(\n    500.0, #ω_lp: Cut-off frequency for LowPass filter of PLL filter.\n    0.084, #k_p: PLL proportional gain\n    4.69,\n) #k_i: PLL integral gain\n\nvirtual_H = PSY.VirtualInertia(\n    2.0, #Ta:: VSM inertia constant\n    400.0, #kd:: VSM damping coefficient\n    20.0, #kω:: Frequency droop gain in pu\n    2 * pi * 50.0,\n) #ωb:: Rated angular frequency\n\nQ_control = PSY.ReactivePowerDroop(\n    0.2, #kq:: Reactive power droop gain in pu\n    1000.0,\n) #ωf:: Reactive power cut-off low pass filter frequency\n\nouter_control = PSY.VirtualInertiaQdroop(virtual_H, Q_control)\n\nvsc = PSY.CombinedVIwithVZ(\n    0.59, #kpv:: Voltage controller proportional gain\n    736.0, #kiv:: Voltage controller integral gain\n    0.0, #kffv:: Binary variable enabling the voltage feed-forward in output of current controllers\n    0.0, #rv:: Virtual resistance in pu\n    0.2, #lv: Virtual inductance in pu\n    1.27, #kpc:: Current controller proportional gain\n    14.3, #kiv:: Current controller integral gain\n    0.0, #kffi:: Binary variable enabling the current feed-forward in output of current controllers\n    50.0, #ωad:: Active damping low pass filter cut-off frequency\n    0.2,\n) #kad:: Active damping gain\n\ncase9_inv = PSY.DynamicInverter(\n    2, #number\n    \"DARCO\", #name\n    nodes_case9[3], #bus location\n    1.0, #ω_ref\n    0.8, #V_ref\n    0.5, #P_ref\n    -0.3, #Q_ref\n    100.0, #MVABase\n    converter, #Converter\n    outer_control, #OuterControl\n    vsc, #Voltage Source Controller\n    dc_source, #DC Source\n    pll, #Frequency Estimator\n    filt, #Output Filter\n);","category":"page"},{"location":"Examples/example_lines/#Defining-the-Dynamic-System-1","page":"Tutorial 2: Dynamic Lines","title":"Defining the Dynamic System","text":"","category":"section"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"#Create the system\nsys = PSY.System(\n      100.0, #Base MVA\n      frequency = 50.0, #Nominal frequency in Hz\n)\n\n#Add the buses to the system\nfor bus in nodes_case9\n    PSY.add_component!(sys, bus)\nend\n\n#Add the branches to the system\nfor br in branch_case9\n    PSY.add_component!(sys, br)\nend\n\n#Make Line3 a dynamic line\nmake_dynamic_branch!(branch_case9[3], sys)\n\n#Add the loads to the system\nfor load in loads_case9\n    PSY.add_component!(sys, load)\nend\n\n#Add the sources (infinite gens) to the system\nfor source in inf_gen_case9\n    PSY.add_component!(sys, source)\nend\n\n#Add the inverter\nPSY.add_component!(sys, case9_inv)\n\n#Add the generator\nPSY.add_component!(sys, case9_gen)","category":"page"},{"location":"Examples/example_lines/#Step-3:-Build-the-simulation-and-initializing-the-problem-1","page":"Tutorial 2: Dynamic Lines","title":"Step 3: Build the simulation and initializing the problem","text":"","category":"section"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"First, we construct the perturbation, by properly computing the new Ybus:","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"#Obtain perturbed Ybus\nsys2 = PSY.System(\n      100.0, #Base MVA\n      frequency = 50.0, #Nominal frequency in Hz\n)\n\n#Add the buses to the system\nfor bus in nodes_case9\n    PSY.add_component!(sys2, bus)\nend\n\n#Add the fault branches to the system\nfor br in branch_case9_fault\n    PSY.add_component!(sys2, br)\nend\n\n#Make Line3 a dynamic line\nmake_dynamic_branch!(branch_case9_fault[3], sys2)\n\n#Compute the Ybus\nYbus_fault = PSY.Ybus(sys2)[:,:]\n\n#Construct the perturbation\nperturbation_Ybus = ThreePhaseFault(\n    1.0, #change will occur at t = 1.0s\n    Ybus_fault, #new Ybus\n);","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"Now, we check the indexing","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"#Time span of our simulation\ntspan = (0.0, 30.0)\n\n#Define Simulation\nsim = Simulation(\n    sys, #system\n    tspan, #time span\n    perturbation_Ybus, #Type of perturbation\n    initialize_simulation = false #keyword argument to not find initial conditions.\n)\n\next = PSY.get_ext(sim.system) #Obtain ext information of the system\next[\"global_index\"] #Showcase the global indexing of z","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"This is a clear example on which a flat start is not enough to properly initialize the system, so we provide a guess:","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"x0_guess = [\n    1.00, #V1_R\n    1.00, #V2_R\n    1.00, #V3_R\n    0.0, #V1_I\n    -0.01, #V2_I\n    -0.01, #V3_I\n    0.0, #δω_vsm\n    0.2, #δθ_vsm\n    0.025, #qm\n    0.0015, #ξ_d\n    -0.07, #ξ_q\n    0.05, #γ_d\n    -0.001, #γ_q\n    0.95, #ϕ_d\n    -0.10, #ϕ_q\n    1.004, #vpll_d\n    0.0, #vpll_q\n    0.0, #ε_pll\n    0.1, #δθ_pll\n    0.5, #id_cv\n    0.0, #iq_cv\n    0.95, #vod\n    -0.1, #voq\n    0.49, #iod\n    -0.1, #ioq\n    1.0, #eq_p\n    0.47, #ed_p\n    0.6, #δ\n    1.0, #ω\n    2.1, #Vf\n    0.28, #Vr1\n    -0.39, #Vr2,\n    1.0, #Vm\n    0.5, #IL1_R\n    0.5, #IL1_I\n]","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"and with that we can compute our initial condition:","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"sim = Simulation(\n    sys, #system\n    tspan, #time span\n    perturbation_Ybus, #Type of perturbation\n    initial_guess = x0_guess #initial guess.\n)","category":"page"},{"location":"Examples/example_lines/#Step-4:-Run-the-simulation-1","page":"Tutorial 2: Dynamic Lines","title":"Step 4: Run the simulation","text":"","category":"section"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"#Run the simulation\nrun_simulation!(sim, #simulation structure\n                IDA(), #Sundials DAE Solver\n)","category":"page"},{"location":"Examples/example_lines/#Step-5:-Explore-the-solution-1","page":"Tutorial 2: Dynamic Lines","title":"Step 5: Explore the solution","text":"","category":"section"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"using Plots\nvolt = get_voltagemag_series(sim, 2)\nplot(volt, xlabel=\"time\", ylabel=\"Voltage [pu]\", label=\"V_2\")\n\nzoom = [(volt[1][ix], volt[2][ix]) for (ix, s) in enumerate(volt[1]) if (s > 0.90 && s < 1.6)]\nplot(zoom, xlabel=\"time\", ylabel=\"Voltage [pu]\", label=\"V_2\")","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"<img src=\"../../assets/voltage_lines.png\" width=\"75%\"/>","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"⠀","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"<img src=\"../../assets/voltage_zoom_lines.png\" width=\"75%\"/>","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"⠀","category":"page"},{"location":"#LITS.jl-1","page":"Home","title":"LITS.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"LITS.jl is a Julia package for doing Power Systems Dynamic Modeling with Low Inertia Energy Sources.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"You can install it by typing","category":"page"},{"location":"#","page":"Home","title":"Home","text":"pkg> add LITS","category":"page"},{"location":"#Usage-1","page":"Home","title":"Usage","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Once installed, the LITS package can by used by typing:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using LITS","category":"page"},{"location":"#Structure-1","page":"Home","title":"Structure","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The following figure shows the interactions between LITS.jl, PowerSystems.jl, DifferentialEquations.jl and the integrators. The architecture of LITS.jl  is such that the power system models are all self-contained and return the model function evaluations. The Jacobian is calculated through DifferentialEquations.jl's common-interface enabling the use of any solver available in Julia. Considering that the resulting models are differential-algebraic equations (DAE), the implementation focuses on the use of implicit solvers, in particular SUNDIALS since it has exceptional features applicable to large models — for instance, interfacing with distributed linear-solvers and GPU arrays. In addition, automatic differentiation is implemented using ForwardDiff.jl to obtain jacobians to perform small signal analysis.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"<img src=\"./assets/SoftwareLoop.png\" width=\"60%\"/>","category":"page"},{"location":"#","page":"Home","title":"Home","text":"⠀","category":"page"},{"location":"#Contents-1","page":"Home","title":"Contents","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n  \"Examples/example_OMIB.md\",\n  \"Examples/example_lines.md\",\n  \"Models/network.md\",\n  \"Models/gens.md\",\n  \"Models/inverters.md\",\n  \"Models/small.md\",\n]","category":"page"},{"location":"docs/#Documentation-1","page":"Documentation","title":"Documentation","text":"","category":"section"},{"location":"docs/#Requirements-1","page":"Documentation","title":"Requirements","text":"","category":"section"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"Pkg.add(\"Documenter\")","category":"page"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"pip install ghp-import","category":"page"},{"location":"docs/#Run-1","page":"Documentation","title":"Run","text":"","category":"section"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"cd docs\nmake html\nopen build/index.html","category":"page"}]
}
