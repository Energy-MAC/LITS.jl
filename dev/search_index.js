var documenterSearchIndex = {"docs":
[{"location":"Models/inverters/#Inverter-Models-1","page":"Inverter","title":"Inverter Models","text":"","category":"section"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"Here we discuss the structure and models used to model inverters in LITS.jl. Each inverter is a data structure that is defined by the following components:","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"DC Source: Defines the dynamics of the DC side of the converter.\nFrequency Estimator: That describes how the frequency of the grid can be estimated using the grid voltages. Typically a phase-locked loop (PLL).\nOuter Loop Control: That describes the active and reactive power control dynamics.\nInner Loop Control: That can describe virtual impedance, voltage control and current control dynamics.\nConverter: That describes the dynamics of the pulse width modulation (PWM) or space vector modulation (SVM).\nFilter: Used to connect the converter output to the grid.","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"The following figure summarizes the components of a inverter and which variables they share:","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"<img src=\"../../assets/inv_metamodel.png\" width=\"75%\"/>","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"â €","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"Contrary to the generator, there are many control structures that can be used to model inverter controllers (e.g. grid-following, grid feeding or virtual synchronous machine). For this purpose, more variables are shared among the components in order to cover all these posibilities.","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"Models are based from the paper: \"A Virtual Synchronous Machine implementation for distributed control of power converters in SmartGrids\" from S. D'Arco, J.A. Suul and O.B. Fosso.","category":"page"},{"location":"Models/inverters/#DC-Source-1","page":"Inverter","title":"DC Source","text":"","category":"section"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"This component can be used to model the dynamics of the DC side of the converter.","category":"page"},{"location":"Models/inverters/#Fixed-DC-Source-1","page":"Inverter","title":"Fixed DC Source","text":"","category":"section"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"This is a model that set the DC voltage to a fixed value v_textdc = v_textdc^textfix.","category":"page"},{"location":"Models/inverters/#Frequency-Estimators-1","page":"Inverter","title":"Frequency Estimators","text":"","category":"section"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"This component is used to estimate the frequency of the grid based on the voltage at the bus.","category":"page"},{"location":"Models/inverters/#Phase-Locked-Loop-(PLL)-for-VSM-1","page":"Inverter","title":"Phase-Locked Loop (PLL) for VSM","text":"","category":"section"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"The following equations present a PLL used to estimate the frequency and PLL angle of the grid. There are two reference frames considered in this inverter. Those are the VSM of the outer-loop control deltatheta_textolc and the PLL one deltatheta_textpll. The notation used a deltatheta to refer as the variation of the respective angle theta with respect to the grid SRF (instead of the fixed alpha component of the alphabeta transformation):","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"beginalign\ndotv_dtextpll = omega_textlp left v_d cos(deltatheta_textpll - deltatheta_textolc) + v_q sin(deltatheta_textpll - deltatheta_textolc) - v_dtextpll right tag1a \ndotv_qtextpll = omega_textlp left - v_d sin(deltatheta_textpll - deltatheta_textolc) + v_q cos(deltatheta_textpll - deltatheta_textolc) - v_qtextpll right tag1b \ndotvarepsilon_textpll = tan^-1left(fracv_qtextpllv_dtextpll right) tag1c \ndotdeltatheta_textpll = Omega_b delta omega_textpll tag1d\nendalign","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"with","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"beginalign\ndeltaomega_textpll = k_ptextpll tan^-1 left(fracv_qtextpllv_dtextpll right) + k_itextpll varepsilon_textpll tag1e\nendalign","category":"page"},{"location":"Models/inverters/#Outer-Loop-Controls-1","page":"Inverter","title":"Outer Loop Controls","text":"","category":"section"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"This component defines controllers for both active and reactive power","category":"page"},{"location":"Models/inverters/#Virtual-Inertia-and-Q-droop-1","page":"Inverter","title":"Virtual Inertia and Q-droop","text":"","category":"section"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"The following model represent a virtual synchronous machine model to represent how active power is going to be deployed. It defines a new SRF denoted as theta_textolc for the active power controller and uses a simple voltage droop for dispatching reactive power:","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"beginalign\n    dotdeltaomega_textolc = fracp_textrefT_a - fracp_eT_a - frack_d(omega_textvsm - omega_textpll)T_a - frack_omega(omega_textolc - omega_textref)T_a tag2a \n    dotdeltatheta_textolc = Omega_b deltaomega_textolc tag2b \n    dotq_m = omega_f (q_e - q_m) tag2c\nendalign","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"with","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"beginalign\n    p_e = v_di_d + v_qi_q tag2d \n    q_e = v_qi_d - v_di_q tag2e \n    v_textolc^textref = v_textref + k_q(q_textref - q_m) tag2f\nendalign","category":"page"},{"location":"Models/inverters/#Inner-Loop-Controls-1","page":"Inverter","title":"Inner Loop Controls","text":"","category":"section"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"This component defines voltage and current controllers to generate the reference signal for the converter.","category":"page"},{"location":"Models/inverters/#Integrated-Virtual-Impedance,-Voltage-and-Current-Controller-1","page":"Inverter","title":"Integrated Virtual Impedance, Voltage and Current Controller","text":"","category":"section"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"The following model receives both the outer loop control frequency and reference voltage signal to generate the reference signal for the converters. The virtual impedance plays a similar role of the impedance of a synchronous generator. A PI voltage controller is used to generate the current signal that is used in the PI current controller to finally generate the voltage reference signal for the converters.","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"beginalign*\n    dotxi_d = v_dtextvi^textref - v_d tag3a \n    dotxi_q = v_qtextvi^textref - v_q tag3b \n    dotgamma_d = i_dtextcv^textref - i_dtextcv tag3c \n    dotgamma_q = i_qtextcv^textref - i_qtextcv tag3d \n    dotphi_d = omega_textad(v_d - phi_d) tag3e \n    dotphi_q = omega_textad(v_q - phi_q) tag3f\nendalign*","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"with","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"beginalign\n    v_dtextvi^textref = v_textolc^textref - r_v i_d + omega_textolc l_v i_q tag3g \n    v_qtextvi^textref = - r_v i_q - omega_textolc l_v i_d tag3h \n    i_dtextcv^textref = k_pvleft(v_dtextvi^textref - v_qright) + k_iv xi_d - c_f omega_textolc v_q + k_textffii_d tag3i \n    i_qtextcv^textref = k_pvleft(v_qtextvi^textref - v_qright) + k_iv xi_q + c_f omega_textolc v_d + k_textffii_q tag3j \n    v_d^textref-signal = k_pc left(i_dtextcv^textref - i_dtextcvright) + k_ic gamma_d - omega_textolc l_f i_qtextcv + k_textffvv_d - k_textad(v_d - phi_d) tag3k \n    v_q^textref-signal = k_pc left(i_qtextcv^textref - i_qtextcvright) + k_ic gamma_q + omega_textolc l_f i_dtextcv + k_textffvv_q - k_textad(v_q - phi_q) tag3l\nendalign","category":"page"},{"location":"Models/inverters/#Converter-1","page":"Inverter","title":"Converter","text":"","category":"section"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"This component can be used to model the dynamics of the switching process.","category":"page"},{"location":"Models/inverters/#Average-Model-1","page":"Inverter","title":"Average Model","text":"","category":"section"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"The average model simply output the desired reference signal since:","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"beginalign\nv_d^textcv approx m_d v_textdc approx fracv_d^textref-signalv_textdc v_textdc approx v_d^textref-signal tag4a \nv_q^textcv approx m_q v_textdc approx fracv_q^textref-signalv_textdc v_textdc approx v_q^textref-signal tag4b\nendalign","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"where m_dq is the modulation signal, and v_dq^textref-signal is the voltage reference signal from the inner loop control.","category":"page"},{"location":"Models/inverters/#Filters-1","page":"Inverter","title":"Filters","text":"","category":"section"},{"location":"Models/inverters/#LCL-Filter-1","page":"Inverter","title":"LCL Filter","text":"","category":"section"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"A standard LCL filter is proposed to connect the output of the converter to the grid. In this case, v_d and v_q are voltages in the capacitor, while v_d^textgrid and v_q^textgrid represent the voltage at the bus. The L filter after the capacitor can also include a step-up transformer to increase the voltage, that is model as an extra impedance.","category":"page"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"beginalign\n    doti_dtextcv = fracOmega_bl_fleft( v_d^textcv - v_d  - r_f i_dtextcv + omega_textgrid l_f i_qtextcv right) tag5a \n    doti_qtextcv = fracOmega_bl_fleft( v_q^textcv - v_q  - r_f i_qtextcv - omega_textgrid l_f i_dtextcv right) tag5b \n    dotv_d =  fracOmega_bc_fleft( i_d^textcv - i_d + omega_textgrid c_f v_q right) tag5c \n    dotv_q =  fracOmega_bc_fleft( i_q^textcv - i_q - omega_textgrid c_f v_d right) tag5d \n    doti_d = fracOmega_bl_gleft( v_d^textcv - v_d^textgrid - r_g i_d + omega_textgrid l_g i_qtextcv right) tag5e \n    doti_q = fracOmega_bl_gleft( v_q^textcv - v_q^textgrid - r_g i_q - omega_textgrid l_g i_dtextcv right) tag5f\nendalign","category":"page"},{"location":"Models/inverters/#Reference-1","page":"Inverter","title":"Reference","text":"","category":"section"},{"location":"Models/inverters/#","page":"Inverter","title":"Inverter","text":"LITS.FixedDCSource\nLITS.PLL\nLITS.VirtualInertia\nLITS.ReactivePowerDroop\nLITS.VirtualInertiaQdroop\nLITS.CombinedVIwithVZ\nLITS.AvgCnvFixedDC\nLITS.LCLFilter","category":"page"},{"location":"Models/inverters/#LITS.FixedDCSource","page":"Inverter","title":"LITS.FixedDCSource","text":"Parameters of a Fixed DC Source that returns a fixed DC voltage\n\nConmutable structor\n\nFixedDCSource(voltage)\n\nArguments\n\nvoltage::Float64 : Fixed DC voltage to the converter\n\n\n\n\n\n","category":"type"},{"location":"Models/inverters/#LITS.PLL","page":"Inverter","title":"LITS.PLL","text":"Parameters of a Phase-Locked Loop (PLL) for VSM\n\nConmutable structor\n\nPLL(Ï‰_lp, kp_pll, ki_pll)\n\nArguments\n\nÏ‰_lp::Float64 : PLL low-pass filter frequency (rad/sec)\nkp_pll::Float64 : PLL proportional gain\nki_pll::Float64 : PLL integral gain\n\n\n\n\n\n","category":"type"},{"location":"Models/inverters/#LITS.VirtualInertia","page":"Inverter","title":"LITS.VirtualInertia","text":"Parameters of a Virtual Inertia with SRF using VSM for active power controller\n\nConmutable structor\n\nVirtualInertia(Ta, kd, kw, Ï‰b)\n\nArguments\n\nTa::Float64 : VSM inertia constant\nkd::Float64 : VSM damping constant\nkw::Float64 : frequency droop gain\nÏ‰b::Float64 : rated angular frequency\n\n\n\n\n\n","category":"type"},{"location":"Models/inverters/#LITS.ReactivePowerDroop","page":"Inverter","title":"LITS.ReactivePowerDroop","text":"Parameters of a Reactive Power droop controller\n\nConmutable structor\n\nReactivePowerDroop(kq, Ï‰f)\n\nArguments\n\nkq::Float64 : reactive power droop gain\nÏ‰f::Float64 : reactive power filter cutoff frequency (rad/sec)\n\n\n\n\n\n","category":"type"},{"location":"Models/inverters/#LITS.VirtualInertiaQdroop","page":"Inverter","title":"LITS.VirtualInertiaQdroop","text":"Parameters of a Outer-Loop controller using a virtual inertia with VSM for active power controller and a reactive power droop controller.\n\nConmutable structor\n\nVirtualInertiaQDroop(A, R)\n\nArguments\n\nA::Float64 : Active power controller using virtual inertia with VSM\nR::Float64 : Reactive power controller using reactive power droop\n\n\n\n\n\n","category":"type"},{"location":"Models/inverters/#LITS.CombinedVIwithVZ","page":"Inverter","title":"LITS.CombinedVIwithVZ","text":"Parameters of an inner loop controller using virtual impedance, voltage controller and current controller.\n\nConmutable structor\n\nCombinedVIwithVZ(kpv, kiv, kffv, rv, lv, kpc, kic, kffi, Ï‰ad, kad)\n\nArguments\n\nkpv::Float64 : voltage controller proportional gain\nkiv::Float64 : voltage controller integral gain\nkffv::Float64 : Binary variable to enable feed-forward gain of voltage.\nrv::Float64 : virtual resistance\nlv::Float64 : virtual inductance\nkpc::Float64 : current controller proportional gain\nkic::Float64 : current controller integral gain\nkffi::Float64 : Binary variable to enable feed-forward gain of current\nÏ‰ad::Float64 : active damping filter cutoff frequency (rad/sec)\nkad::Float64 : active damping gain\n\n\n\n\n\n","category":"type"},{"location":"Models/inverters/#LITS.AvgCnvFixedDC","page":"Inverter","title":"LITS.AvgCnvFixedDC","text":"Parameters of an average converter model\n\nConmutable structor\n\nAvgCnvFixedDC(v_rated, s_rated)\n\nArguments\n\nv_rated::Float64 : rated voltage\ns_rated::Float64 : rated VA\n\n\n\n\n\n","category":"type"},{"location":"Models/inverters/#LITS.LCLFilter","page":"Inverter","title":"LITS.LCLFilter","text":"Parameters of a LCL filter outside the converter\n\nConmutable structor\n\nLCLFilter(lf, rf, cf, lg, rg)\n\nArguments\n\nlf::Float64 : Series inductance in p.u. of converter filter\nrf::Float64 : Series resistance in p.u. of converter filter\ncf::Float64 : Shunt capacitance in p.u. of converter filter\nlg::Float64 : Series inductance in p.u. of converter filter to the grid\nrg::Float64 : Series resistance in p.u. of converter filter to the grid\n\n\n\n\n\n","category":"type"},{"location":"Models/network/#Network-model-1","page":"Network","title":"Network model","text":"","category":"section"},{"location":"Models/network/#","page":"Network","title":"Network","text":"Here we discuss the models used to describe the network in LITS.jl. This is based on a standard current injection model as defined in Federico Milano's book: Power System Modelling and Scripting. The numerical advantages of current injection models outweigh the complexities of implementing constant power loads for longer-term transient stability analysis. The network is defined in a synchronous reference frame (SRF), named the RI (real-imaginary) reference frame, rotating at the constant base frequency Omega_b.","category":"page"},{"location":"Models/network/#","page":"Network","title":"Network","text":"In simple terms, LITS.jl internally tracks the current-injection balances at the nodal level from all the devices on the system. Based on the buses and branches information, the system constructor computes the admittance matrix boldsymbolY assuming nominal frequency and this is used for static branch modeling. The algebraic equations for the static portions of the network are as follows:","category":"page"},{"location":"Models/network/#","page":"Network","title":"Network","text":" beginalign\n 0 = boldsymboli(boldsymbolx boldsymbolv) - boldsymbolYboldsymbolx\n endalign","category":"page"},{"location":"Models/network/#","page":"Network","title":"Network","text":"where boldsymboli is the vector of the sum of complex current injections from devices, boldsymbolx is the vector of states and boldsymbolv is the vector of complex bus voltages. Equations (1) connect all the port variables, i.e., currents, defined for each injection device. Components that contribute to (1) by modifying the current boldsymboli are (i) static injection devices, (ii) dynamic injection devices, and (iii) dynamic network branches. Components that contribute to modify the admittance matrix boldsymbolY are static branches.","category":"page"},{"location":"Models/network/#Static-Branches-(or-simply-Branches)-1","page":"Network","title":"Static Branches (or simply Branches)","text":"","category":"section"},{"location":"Models/network/#Lines-1","page":"Network","title":"Lines","text":"","category":"section"},{"location":"Models/network/#","page":"Network","title":"Network","text":"Each line is defined using a pi model connecting two buses (nm), with a series resistance r and reactance x, and a shunt capacitance at both ends (c_n c_m). The values are already in system per unit. Then each branch contributes to the admittance matrix as follows:","category":"page"},{"location":"Models/network/#","page":"Network","title":"Network","text":"beginalign\nY_nn += frac1r+jx + jc_n \nY_nm += frac-1r+jx \nY_mm += frac1r+jx + jc_m \nY_mn += frac-1r+jx \nendalign","category":"page"},{"location":"Models/network/#Two-Windings-Transformers-1","page":"Network","title":"Two-Windings Transformers","text":"","category":"section"},{"location":"Models/network/#","page":"Network","title":"Network","text":"Similarly to lines these are defined by a series reactance and impedance. The equations are equivalently of the lines without the shunt capacitance.","category":"page"},{"location":"Models/network/#Dynamic-Branches-1","page":"Network","title":"Dynamic Branches","text":"","category":"section"},{"location":"Models/network/#","page":"Network","title":"Network","text":"Dynamic network branches contribute directly to (1) by modifying the vector of complex currents. Their parameters are also the series resistance r and reactance x, and a shunt capacitance at both ends (c_n c_m) for a line ell. In addition, they define 3 new additional differential equations per line (6 in total for real and imaginary part):","category":"page"},{"location":"Models/network/#","page":"Network","title":"Network","text":"beginalign\n    fraclOmega_b fracdi_elldt = (v_n - v_m) - (r+jl) i_ell \n     fracc_nOmega_b fracdv_ndt =  i_n^textcap - jc_nv_n   \n      fracc_mOmega_b fracdv_mdt = i_m^textcap - jc_mv_m\nendalign","category":"page"},{"location":"Models/network/#","page":"Network","title":"Network","text":"Since all the values are in per unit, the reactance is equal to the inductance.","category":"page"},{"location":"api/LITS/#LITS-1","page":"LITS","title":"LITS","text":"","category":"section"},{"location":"api/LITS/#","page":"LITS","title":"LITS","text":"CurrentModule = LITS\nDocTestSetup  = quote\n    using LITS\nend","category":"page"},{"location":"api/LITS/#","page":"LITS","title":"LITS","text":"API documentation","category":"page"},{"location":"api/LITS/#","page":"LITS","title":"LITS","text":"Pages = [\"LITS.md\"]","category":"page"},{"location":"api/LITS/#Index-1","page":"LITS","title":"Index","text":"","category":"section"},{"location":"api/LITS/#","page":"LITS","title":"LITS","text":"Pages = [\"LITS.md\"]","category":"page"},{"location":"api/LITS/#Exported-1","page":"LITS","title":"Exported","text":"","category":"section"},{"location":"api/LITS/#","page":"LITS","title":"LITS","text":"Modules = [LITS]\nPrivate = false","category":"page"},{"location":"api/LITS/#LITS.AVRTypeIIManual","page":"LITS","title":"LITS.AVRTypeIIManual","text":"Parameters of an Automatic Voltage Regulator Type II from PSAT Manual -  Typical static exciter model\n\nConmutable structor\n\nAVRTypeII(K0, T1, T2, T3, T4, Te, Tr, Vr_max, Vr_min, Ae, Be)\n\nArguments\n\nKf::Float64 : Regulator Gain\nTa::Float64 : Amplifier time constant\nKf::Float64 : Stabilizer gain\nTf::Float64 : Stabilizer time constant\nTe::Float64 : Field Circuit Time Constant in s\nTr::Float64 : Voltage Measurement Time Constant in s\nVr_max::Float64 : Maximum regulator voltage in pu\nVr_min::Float64 : Minimum regulator voltage in pu\nAe::Float64 : 1st ceiling coefficient\nBe::Float64 : 2nd ceiling coefficient\n\n\n\n\n\n","category":"type"},{"location":"api/LITS/#LITS.DynGenerator","page":"LITS","title":"LITS.DynGenerator","text":"\n\n\n\n","category":"type"},{"location":"api/LITS/#LITS.StaticSource","page":"LITS","title":"LITS.StaticSource","text":"This struct acts as an infinity bus.\n\n\n\n\n\n","category":"type"},{"location":"api/LITS/#Internal-1","page":"LITS","title":"Internal","text":"","category":"section"},{"location":"api/LITS/#","page":"LITS","title":"LITS","text":"Modules = [LITS]\nPublic = false","category":"page"},{"location":"api/LITS/#LITS.DirectControl","page":"LITS","title":"LITS.DirectControl","text":"kpc::Float64 : current controller proportional gain\nkic::Float64 : current controller integral gain\nkpv::Float64 : voltage controller proportional gain\nkiv::Float64 : voltage controller integral gain\nÏ‰_ad::Float64 : active damping filter cutoff frequency (rad/sec)\nkad::Float64 : active damping gain\nlv::Float64 : virtual inductance\nrv::Float64 : virtual resistance\n\n\n\n\n\n","category":"type"},{"location":"api/LITS/#LITS.LCFilter","page":"LITS","title":"LITS.LCFilter","text":"lf::Float64 : filter inductance\nrf::Float64 : filter resistance\ncf::Float64 : filter capacitance\n\n\n\n\n\n","category":"type"},{"location":"Models/gens/#Generator-Models-1","page":"Generator","title":"Generator Models","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"Here we discuss the structure and models used to model generators in LITS.jl. Each generator is a data structure that is defined by the following components:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"Machine: That defines the stator electro-magnetic dynamics.\nShaft: That describes the rotor electro-mechanical dynamics.\nAutomatic Voltage Regulator: Electromotive dynamics to model an AVR controller.\nPower System Stabilizer: Control dynamics to define an stabilization signal for the AVR.\nPrime Mover and Turbine Governor: Thermo-mechanical dynamics and associated controllers.","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"The following figure summarizes the components of a generator and which variables they share:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"<img src=\"../../assets/gen_metamodel.png\" width=\"75%\"/>","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"â €","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"Each generator is defined in its own dq reference frame. Let delta be the rotor angle of the generator. If v_r + jv_i = v_hangle theta defines the voltage in the bus in the network reference frame RI rotating at nominal frequency Omega_b, then the following equations (both are equivalent) can be used to convert between reference frames:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\nleft beginarrayc v_d  v_q endarray right =  left beginarrayc v_h sin(delta - theta)  v_h cos(delta - theta) endarray right  tag0a \nleft beginarrayc v_d  v_q endarray right = left beginarraycc sin(delta)  -cos(delta)  cos(delta)  sin(delta) endarray right left beginarrayc v_r  v_i endarray right tag0b\nendalign","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"Models are based from Federico Milano's book: \"Power System Modelling and Scripting\" and Prabha Kundur's book: \"Power System's Stability and Control\"","category":"page"},{"location":"Models/gens/#Machines-1","page":"Generator","title":"Machines","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"The machine component describes the stator-rotor electromagnetic dynamics.","category":"page"},{"location":"Models/gens/#Classical-Model-(Zero-Order)-1","page":"Generator","title":"Classical Model (Zero Order)","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This is the classical order model that does not have differential equations in its machine model (delta and omega are defined in the shaft):","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\n  left beginarrayc i_d  i_q endarray right = left beginarraycc r_a  -x_d  x_d  r_a endarray right^-1  left beginarrayc -v_d  e_q - v_q endarray right tag1a\np_e approx tau_e = (v_q + r_a i_q)i_q + (v_d + r_ai_d)i_d tag1b\nendalign","category":"page"},{"location":"Models/gens/#One-d-One-q-Model-(2th-Order)-1","page":"Generator","title":"One d- One q- Model (2th Order)","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This model includes two transient emf with their respective differential equations:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\ndote_q = frac1T_d0 left-e_q + (x_d-x_d)i_d + v_fright tag2a\ndote_d = frac1T_q0 left-e_d + (x_q-x_q)i_q right tag2b\n  left beginarrayc i_d  i_q endarray right = left beginarraycc r_a  -x_q  x_d  r_a endarray right^-1  left beginarrayc e_d-v_d  e_q - v_q endarray right tag2c\np_e approx tau_e = (v_q + r_a i_q)i_q + (v_d + r_ai_d)i_d tag2d\nendalign","category":"page"},{"location":"Models/gens/#Marconato-Machine-(6th-Order)-1","page":"Generator","title":"Marconato Machine (6th Order)","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"The Marconato model defines 6 differential equations, two for stator fluxes and 4 for transient and subtransient emfs:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\ndotpsi_d = Omega_b(r_ai_d + omega psi_q + v_d) tag3a \ndotpsi_q = Omega_b(r_ai_q - omega psi_d + v_q) tag3b \ndote_q = frac1T_d0 left-e_q - (x_d-x_d-gamma_d)i_d + left(1- fracT_AAT_d0 right) v_fright tag3c\ndote_d = frac1T_q0 left-e_d + (x_q-x_q-gamma_q)i_q right tag3d\ndote_q = frac1T_d0 left-e_q + e_q - (x_d-x_d+gamma_d)i_d + fracT_AAT_d0v_f right tag3e \ndote_d = frac1T_q0 left-e_d + e_d + (x_q-x_q+gamma_q)i_q right tag3f \ni_d = frac1x_d (e_q - psi_d) tag3g \ni_q = frac1x_q (-e_d - psi_q) tag3h \ntau_e = psi_d i_q - psi_q i_d tag3i\nendalign","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"with","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign*\n  gamma_d = fracT_d0 x_dT_d0 x_d (x_d - x_d) \n  gamma_q = fracT_q0 x_qT_q0 x_q (x_q - x_q)\nendalign*","category":"page"},{"location":"Models/gens/#Simplified-Marconato-Machine-(4th-Order)-1","page":"Generator","title":"Simplified Marconato Machine (4th Order)","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This model neglects the derivative of stator fluxes (dotpsi_d and  dotpsi_q) and assume that the rotor speed stays close to 1 pu (omegapsi_d=psi_d and omegapsi_q=psi_q) that allows to remove the stator fluxes variables from the Marconato model.","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\ndote_q = frac1T_d0 left-e_q - (x_d-x_d-gamma_d)i_d + left(1- fracT_AAT_d0 right) v_fright tag4a\ndote_d = frac1T_q0 left-e_d + (x_q-x_q-gamma_q)i_q right tag4b\ndote_q = frac1T_d0 left-e_q + e_q - (x_d-x_d+gamma_d)i_d + fracT_AAT_d0v_f right tag4c \ndote_d = frac1T_q0 left-e_d + e_d + (x_q-x_q+gamma_q)i_q right tag4d \nleft beginarrayc i_d  i_q endarray right = left beginarraycc r_a  -x_q  x_d  r_a endarray right^-1  left beginarrayc e_d-v_d  e_q - v_q endarray right tag4e\np_e approx tau_e = (v_q + r_a i_q)i_q + (v_d + r_ai_d)i_d tag4f\nendalign","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"with","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign*\n  gamma_d = fracT_d0 x_dT_d0 x_d (x_d - x_d) \n  gamma_q = fracT_q0 x_qT_q0 x_q (x_q - x_q)\nendalign*","category":"page"},{"location":"Models/gens/#Anderson-Fouad-Machine-(6th-Order)-1","page":"Generator","title":"Anderson-Fouad Machine (6th Order)","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"The Anderson-Fouad model also defines 6 differential equations, two for stator fluxes and 4 for transient and subtransient emfs and is derived from the Marconato model by defining gamma_d approx gamma_q approx T_AA approx 0:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\ndotpsi_d = Omega_b(r_ai_d + omega psi_q + v_d) tag5a \ndotpsi_q = Omega_b(r_ai_q - omega psi_d + v_q) tag5b \ndote_q = frac1T_d0 left-e_q - (x_d-x_d)i_d + v_fright tag5c\ndote_d = frac1T_q0 left-e_d + (x_q-x_q)i_q right tag5d\ndote_q = frac1T_d0 left-e_q + e_q - (x_d-x_d)i_d right tag5e \ndote_d = frac1T_q0 left-e_d + e_d + (x_q-x_q)i_q right tag5f \ni_d = frac1x_d (e_q - psi_d) tag5g \ni_q = frac1x_q (-e_d - psi_q) tag5h \ntau_e = psi_d i_q - psi_q i_d tag5i\nendalign","category":"page"},{"location":"Models/gens/#Simplified-Anderson-Fouad-Machine-(4th-Order)-1","page":"Generator","title":"Simplified Anderson-Fouad Machine (4th Order)","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"Similar to the Simplified Marconato Model, this model neglects the derivative of stator fluxes (dotpsi_d and  dotpsi_q) and assume that the rotor speed stays close to 1 pu (omega psi_d = psi_d and omega psi_q = psi_q) that allows to remove the stator fluxes variables from the model:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\ndote_q = frac1T_d0 left-e_q - (x_d-x_d)i_d + v_fright tag6a\ndote_d = frac1T_q0 left-e_d + (x_q-x_q)i_q right tag6b\ndote_q = frac1T_d0 left-e_q + e_q - (x_d-x_d)i_d right tag6c \ndote_d = frac1T_q0 left-e_d + e_d + (x_q-x_q)i_q right tag6d \nleft beginarrayc i_d  i_q endarray right = left beginarraycc r_a  -x_q  x_d  r_a endarray right^-1  left beginarrayc e_d-v_d  e_q - v_q endarray right tag6e\np_e approx tau_e = (v_q + r_a i_q)i_q + (v_d + r_ai_d)i_d tag6f\nendalign","category":"page"},{"location":"Models/gens/#Rotor-Fluxes-Model-(5th-Order)-1","page":"Generator","title":"Rotor Fluxes Model (5th Order)","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This models describes a machine model using 2 stator fluxes psi_d and psi_q, the rotor field flux psi_f, the d-axis damping psi_1d and only one q-axis damping circuit psi_1q:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\ndotpsi_d = Omega_b(r_a i_d + omega psi_q + v_d) tag7a \ndotpsi_q = Omega_b(r_ai_q - omega psi_d + v_q) tag7b \ndotpsi_f = -r_f i_f + v_f tag7c\ndotpsi_1d = -r_1di_1d tag7d\ndotpsi_1q = -r_1qi_1q tag7e \nleft beginarrayc i_d  i_f  i_1d endarray right = left beginarrayccc -L_d  -L_ad  L_ad  -L_ad  L_ff  L_f1d  -L_ad  L_f1d  L_1d endarray right^-1  left beginarrayc psi_d  psi_f   psi_1d endarray right tag7f\nleft beginarrayc i_q  i_1q  endarray right = left beginarrayccc -L_q  L_aq   -L_aq  L_1q endarray right^-1  left beginarrayc psi_q  psi_1q  endarray right tag7g\ntau_e = psi_d i_q - psi_q i_d tag7h\nendalign","category":"page"},{"location":"Models/gens/#Shafts-1","page":"Generator","title":"Shafts","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"The shaft component defines the rotating mass of the synchronous generator.","category":"page"},{"location":"Models/gens/#Rotor-Mass-Shaft-1","page":"Generator","title":"Rotor Mass Shaft","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This is the standard model, on which one single mass (typically the rotor) is used to model the entire inertia of the synchronous generator. Each generator's rotating frame use a reference frequency omega_s, that typically is the synchronous one (i.e. omega_s = 10). The model defines two differential equations for the rotor angle delta and the rotor speed omega:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\ndotdelta = Omega_b(omega - omega_s) tag8a \ndotomega = frac12H(tau_m - tau_e - D(omega-omega_s)) tag8b\nendalign","category":"page"},{"location":"Models/gens/#Five-Mass-Shaft-1","page":"Generator","title":"Five-Mass Shaft","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This model describes model connecting a high-pressure (hp) steam turbine, intermediate-pressure (ip) steam turbine, low-pressure (lp) steam pressure, rotor and exciter (ex) connected in series (in that order) in the same shaft using a spring-mass model:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\ndotdelta = Omega_b(omega - omega_s) tag9a \ndotomega = frac12H left- tau_e - D(omega-omega_s)) - D_34 (omega-omega_lp) - D_45(omega-omega_ex) + K_lp(delta_lp-delta) +K_ex(delta_ex-delta) right tag9b \ndotdelta_hp = Omega_b(omega_hp - omega_s) tag9c \ndotomega_hp = frac12H_hp left tau_m - D_hp(omega_hp-omega_s) - D_12(omega_hp - omega_ip) + K_hp(delta_ip - delta_hp) right tag9d \ndotdelta_ip = Omega_b(omega_ip - omega_s) tag9e \ndotomega_ip = frac12H_ip left- D_ip(omega_ip-omega_s) - D_12(omega_ip - omega_hp) -D_23(omega_ip - omega_lp ) + K_hp(delta_hp - delta_ip) + K_ip(delta_lp-delta_ip) right tag9f \ndotdelta_lp = Omega_b(omega_lp-omega_s) tag9g \ndotomega_lp = frac12H_lp left - D_lp(omega_lp-omega_s) - D_23(omega_lp - omega_ip) -D_34(omega_lp - omega ) + K_ip(delta_ip - delta_lp) + K_lp(delta-delta_lp) right tag9h \ndotdelta_ex = Omega_b(omega_ex-omega_s) tag9i \ndotomega_ex = frac12H_ex left - D_ex(omega_ex-omega_s) - D_45(omega_ex - omega) + K_ex(delta - delta_ex) right tag9j\nendalign","category":"page"},{"location":"Models/gens/#Automatic-Voltage-Regulators-(AVR)-1","page":"Generator","title":"Automatic Voltage Regulators (AVR)","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"AVR are used to determine the voltage in the field winding v_f in the model.","category":"page"},{"location":"Models/gens/#Fixed-AVR-1","page":"Generator","title":"Fixed AVR","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This is a simple model that set the field voltage to be equal to a desired constant value v_f = v_textfix.","category":"page"},{"location":"Models/gens/#Simple-AVR-1","page":"Generator","title":"Simple AVR","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This depicts the most basic AVR, on which the field voltage is an integrator over the difference of the measured voltage and a reference:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\ndotv_f = K_v(v_textref - v_h) tag10a\nendalign","category":"page"},{"location":"Models/gens/#AVR-Type-I-1","page":"Generator","title":"AVR Type I","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This AVR is a simplified version of the IEEE DC1 AVR model:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\ndotv_f = -frac1T_e left V_f(K_e + S_e(v_f))-v_r1 right tag11a \ndotv_r1 = frac1T_a left K_aleft(v_textref - v_m - v_r2 - fracK_fT_fv_fright) - v_r1 right   tag11b \ndotv_r2 =  -frac1T_f left fracK_fT_fv_f + v_r2 right  tag11c \ndotv_m = frac1T_r (v_h - v_m) tag11d\nendalign","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"with the ceiling function:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign*\nS_e(v_f) = A_e exp(B_ev_f)\nendalign*","category":"page"},{"location":"Models/gens/#AVR-Type-II-1","page":"Generator","title":"AVR Type II","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This model represents a static exciter with higher gains and faster response than the Type I:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\ndotv_f = -frac1T_e left V_f(1 + S_e(v_f))-v_r right tag12a \ndotv_r1 = frac1T_1 left K_0left(1 - fracT_2T_1 right)(v_textref - v_m) - v_r1  right tag12b \ndotv_r2 =  frac1K_0 T_3 left left( 1 - fracT_4T_3 right) left( v_r1 + K_0fracT_2T_1(v_textref - v_m)right) - K_0 v_r2 right  tag12c \ndotv_m = frac1T_r (v_h - v_m) tag12d\nendalign","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"with","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign*\nv_r = K_0v_r2 + fracT_4T_3 left( v_r1 + K_0fracT_2T_1(v_textref - v_m)right) \nS_e(v_f) = A_e exp(B_ev_f)\nendalign*","category":"page"},{"location":"Models/gens/#Power-System-Stabilizers-(PSS)-1","page":"Generator","title":"Power System Stabilizers (PSS)","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"PSS are used to add an additional signal v_s to the field voltage: v_f = v_f^textavr + v_s.","category":"page"},{"location":"Models/gens/#Fixed-PSS-1","page":"Generator","title":"Fixed PSS","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This is a simple model that set the stabilization signal to be equal to a desired constant value v_s = v_s^textfix. The absence of PSS can be modelled using this component with v_s^textfix = 0.","category":"page"},{"location":"Models/gens/#Simple-PSS-1","page":"Generator","title":"Simple PSS","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This is the most basic PSS that can be implemented, on which the stabilization signal is simply a proportional controller over the frequency and electrical power:","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\nv_s = K_omega(omega - omega_s) + K_p(omega tau_e - P_textref) tag12a\nendalign","category":"page"},{"location":"Models/gens/#Prime-Movers-and-Turbine-Governors-(TG)-1","page":"Generator","title":"Prime Movers and Turbine Governors (TG)","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This section describes how mechanical power is modified to provide primary frequency control with synchronous generators. It is assumed that tau_textref = P_textref since they are decided at nominal frequency omega = 1.","category":"page"},{"location":"Models/gens/#Fixed-TG-1","page":"Generator","title":"Fixed TG","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This a simple model that set the mechanical torque to be equal to a proportion of the desired reference tau_m = eta P_textref. To set the mechanical torque to be equal to the desired power, the value of eta is set to 1.","category":"page"},{"location":"Models/gens/#TG-Type-I-1","page":"Generator","title":"TG Type I","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This turbine governor is described by a droop controller and a low-pass filter to model the governor and two lead-lag blocks to model the servo and reheat of the turbine governor.","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\ndotx_g1 = frac1T_s(p_textin - x_g1) tag13a \ndotx_g2 = frac1T_c left left(1- fract_3T_cright)x_g1 - x_g2 right tag13b \ndotx_g3 = frac1T_5 leftleft(1 - fracT_4T_5right)left(x_g2 + fracT_3T_cx_g1right) - x_g3  right tag13c \ntau_m = x_g3 + fracT_4T_5left(x_g2 + fracT_3T_cx_g1right) tag13d\nendalign","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"with","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign*\np_textin = P_textref + frac1R(omega_s - 1)\nendalign*","category":"page"},{"location":"Models/gens/#TG-Type-II-1","page":"Generator","title":"TG Type II","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"This turbine governor is a simplified model of the Type I.","category":"page"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"beginalign\ndotx_g = frac1T_2leftfrac1Rleft(1 - fracT_1T_2right) (omega_s - omega) - x_gright tag14a \ntau_m = P_textref + frac1RfracT_1T_2(omega_s - omega) tag14b\nendalign","category":"page"},{"location":"Models/gens/#Reference-1","page":"Generator","title":"Reference","text":"","category":"section"},{"location":"Models/gens/#","page":"Generator","title":"Generator","text":"LITS.BaseMachine\nLITS.OneDOneQMachine\nLITS.MarconatoMachine\nLITS.SimpleMarconatoMachine\nLITS.AndersonFouadMachine\nLITS.SimpleAFMachine\nLITS.FullMachine\nLITS.SingleMass\nLITS.FiveMassShaft\nLITS.AVRFixed\nLITS.AVRSimple\nLITS.AVRTypeI\nLITS.AVRTypeII\nLITS.PSSFixed\nLITS.PSSSimple\nLITS.TGFixed\nLITS.TGTypeI\nLITS.TGTypeII","category":"page"},{"location":"Models/gens/#LITS.BaseMachine","page":"Generator","title":"LITS.BaseMachine","text":"Parameters of 0-states synchronous machine: Classical Model\n\nConmutable structor\n\nBaseMachine(R, Xd_p, eq_p, MVABase)\n\nArguments\n\nR::Float64 : Resistance after EMF in machine per unit\nXd_p::Float64 : Reactance after EMF in machine per unit\neq_p::Float64 : Fixed EMF behind the impedance\nMVABase::Float64 : Nominal Capacity in MVA\n\n\n\n\n\n","category":"type"},{"location":"Models/gens/#LITS.OneDOneQMachine","page":"Generator","title":"LITS.OneDOneQMachine","text":"Parameters of 2-states synchronous machine: One d- and One q-Axis Model\n\nConmutable structor\n\nOneDOneQMachine(R, Xd, Xq, Xd_p, Xq_pp, Td0_p, Tq0_pp, MVABase)\n\nArguments\n\nR::Float64\nXd::Float64\nXq::Float64\nXd_p::Float64 : Reactance after EMF in machine per unit\nXq_pp::Float64\nTd0_p::Float64 : Time constant of transient d-axis voltage\nTq0_pp::Float64 : Time constant of subtransient q-axis voltage\nMVABase::Float64 : Nominal Capacity in MVA\n\n\n\n\n\n","category":"type"},{"location":"Models/gens/#LITS.MarconatoMachine","page":"Generator","title":"LITS.MarconatoMachine","text":"Parameters of 6-states synchronous machine: Marconato model\n\nConmutable structor\n\nMarconatoMachine(R, Xd, Xq, Xd_p, Xq_p, Xd_pp, Xq_pp, Td0_p, Tq0_p, Td0_pp, Tq0_pp, T_AA, MVABase)\n\nArguments\n\nR::Float64 : Resistance after EMF in machine per unit\nXd::Float64 : Reactance after EMF in d-axis per unit\nXq::Float64 : Reactance after EMF in q-axis per unit\nXd_p::Float64 : Transient reactance after EMF in d-axis per unit\nXq_p::Float64 : Transient reactance after EMF in q-axis per unit\nXd_pp::Float64 : Subtransient reactance after EMF in d-axis per unit\nXq_pp::Float64 : Subtransient reactance after EMF in q-axis per unit\nTd0_p::Float64 : Time constant of transient d-axis voltage\nTq0_p::Float64 : Time constant of transient q-axis voltage\nTd0_pp::Float64 : Time constant of subtransient d-axis voltage\nTq0_pp::Float64 : Time constant of subtransient q-axis voltage\nT_AA::Float64 : Time constant of d-axis additional leakage\nMVABase::Float64 : Nominal Capacity in MVA\n\n\n\n\n\n","category":"type"},{"location":"Models/gens/#LITS.SimpleMarconatoMachine","page":"Generator","title":"LITS.SimpleMarconatoMachine","text":"Parameters of 4-states synchronous machine: Simplified Marconato model The derivative of stator fluxes (Ïˆd and Ïˆq) is neglected and Ï‰Ïˆd = Ïˆd and Ï‰Ïˆq = Ïˆq is assumed (i.e. Ï‰=1.0). This is standard when transmission network dynamics is neglected.\n\nConmutable structor\n\nSimpleMarconatoMachine(R, Xd, Xq, Xd_p, Xq_p, Xd_pp, Xq_pp, Td0_p, Tq0_p, Td0_pp, Tq0_pp, T_AA, MVABase)\n\nArguments\n\nR::Float64 : Resistance after EMF in machine per unit\nXd::Float64 : Reactance after EMF in d-axis per unit\nXq::Float64 : Reactance after EMF in q-axis per unit\nXd_p::Float64 : Transient reactance after EMF in d-axis per unit\nXq_p::Float64 : Transient reactance after EMF in q-axis per unit\nXd_pp::Float64 : Subtransient reactance after EMF in d-axis per unit\nXq_pp::Float64 : Subtransient reactance after EMF in q-axis per unit\nTd0_p::Float64 : Time constant of transient d-axis voltage\nTq0_p::Float64 : Time constant of transient q-axis voltage\nTd0_pp::Float64 : Time constant of subtransient d-axis voltage\nTq0_pp::Float64 : Time constant of subtransient q-axis voltage\nT_AA::Float64 : Time constant of d-axis additional leakage\nMVABase::Float64 : Nominal Capacity in MVA\n\n\n\n\n\n","category":"type"},{"location":"Models/gens/#LITS.AndersonFouadMachine","page":"Generator","title":"LITS.AndersonFouadMachine","text":"Parameters of 6-states synchronous machine: Anderson-Fouad model\n\nConmutable structor\n\nAndersonFouadMachine(R, Xd, Xq, Xd_p, Xq_p, Xd_pp, Xq_pp, Td0_p, Tq0_p, Td0_pp, Tq0_pp, MVABase)\n\nArguments\n\nR::Float64 : Resistance after EMF in machine per unit\nXd::Float64 : Reactance after EMF in d-axis per unit\nXq::Float64 : Reactance after EMF in q-axis per unit\nXd_p::Float64 : Transient reactance after EMF in d-axis per unit\nXq_p::Float64 : Transient reactance after EMF in q-axis per unit\nXd_pp::Float64 : Subtransient reactance after EMF in d-axis per unit\nXq_pp::Float64 : Subtransient reactance after EMF in q-axis per unit\nTd0_p::Float64 : Time constant of transient d-axis voltage\nTq0_p::Float64 : Time constant of transient q-axis voltage\nTd0_pp::Float64 : Time constant of subtransient d-axis voltage\nTq0_pp::Float64 : Time constant of subtransient q-axis voltage\nMVABase::Float64 : Nominal Capacity in MVA\n\n\n\n\n\n","category":"type"},{"location":"Models/gens/#LITS.SimpleAFMachine","page":"Generator","title":"LITS.SimpleAFMachine","text":"Parameters of 4-states simplified Anderson-Fouad (SimpleAFMachine) model. The derivative of stator fluxes (Ïˆd and Ïˆq) is neglected and Ï‰Ïˆd = Ïˆd and Ï‰Ïˆq = Ïˆq is assumed (i.e. Ï‰=1.0). This is standard when transmission network dynamics is neglected. If transmission dynamics is considered use the full order Anderson Fouad model.\n\nConmutable structor\n\nSimpleAFMachine(R, Xd, Xq, Xd_p, Xq_p, Xd_pp, Xq_pp, Td0_p, Tq0_p, Td0_pp, Tq0_pp, MVABase)\n\nArguments\n\nR::Float64 : Resistance after EMF in machine per unit\nXd::Float64 : Reactance after EMF in d-axis per unit\nXq::Float64 : Reactance after EMF in q-axis per unit\nXd_p::Float64 : Transient reactance after EMF in d-axis per unit\nXq_p::Float64 : Transient reactance after EMF in q-axis per unit\nXd_pp::Float64 : Subtransient reactance after EMF in d-axis per unit\nXq_pp::Float64 : Subtransient reactance after EMF in q-axis per unit\nTd0_p::Float64 : Time constant of transient d-axis voltage\nTq0_p::Float64 : Time constant of transient q-axis voltage\nTd0_pp::Float64 : Time constant of subtransient d-axis voltage\nTq0_pp::Float64 : Time constant of subtransient q-axis voltage\nMVABase::Float64 : Nominal Capacity in MVA\n\n\n\n\n\n","category":"type"},{"location":"Models/gens/#LITS.FullMachine","page":"Generator","title":"LITS.FullMachine","text":"Parameter of a full order flux stator-rotor model without zero sequence flux in the stator. The derivative of stator fluxes (Ïˆd and Ïˆq) is NOT neglected. Only one q-axis damping circuit is considered. All parameters are in machine per unit.\n\nRefer to Chapter 3 of Power System Stability and Control by P. Kundur or Chapter 11 of Power System Dynamics: Stability and Control, by J. Machowski, J. Bialek and J. Bumby, for more details. Note that the models are somewhat different (but equivalent) due to the different Park Transformation used in both books.\n\nConmutable structor\n\nFullMachine(R, R_f, R_1d, R_1q, L_d, L_q, L_ad, L_aq, L_f1d, L_f, L_1d, L_1q)\n\nArguments\n\nR::Float64 : Stator resistance after EMF in per unit\nR_f::Float64 : Field rotor winding resistance in per unit\nR_1d::Float64 : Damping rotor winding resistance on d-axis in per unit.                 This value is denoted as RD in Machowski.\nR_1q::Float64 : Damping rotor winding resistance on q-axis in per unit.                 This value is denoted as RQ in Machowski.\nL_d::Float64 : Inductance of fictitious damping that represent the effect                 of the three-phase stator winding in the d-axis of the rotor, in per unit.                 This value is denoted as Lad + Ll in Kundur (and Ld in Machowski).\nL_q::Float64 : Inductance of fictitious damping that represent the effect                 of the three-phase stator winding in the q-axis of the rotor, in per unit.                 This value is denoted as Laq + Ll in Kundur.\nL_ad::Float64 : Mutual inductance between stator winding and rotor field (and damping)                   winding inductance on d-axis, in per unit\nL_aq::Float64 : Mutual inductance between stator winding and rotor damping winding                   inductance on q-axis, in per unit\nL_f1d::Float64 : Mutual inductance between rotor field winding and rotor damping winding                   inductance on d-axis, in per unit\nL_ff::Float64 : Field rotor winding inductance, in per unit\nL_1d::Float64 : Inductance of the d-axis rotor damping circuit, in per unit\nL_1q::Float64 : Inductance of the q-axis rotor damping circuit, in per unit\nMVABase::Float64 : Nominal Capacity in MVA\n\n\n\n\n\n","category":"type"},{"location":"Models/gens/#LITS.SingleMass","page":"Generator","title":"LITS.SingleMass","text":"Parameters of single mass shaft model. Typically represents the rotor mass.\n\nConmutable structor\n\nSingleMass(H, D)\n\nArguments\n\nH   ::Float64 : Rotor inertia constant in MWs/MVA\nD   ::Float64 : Rotor natural damping in pu\n\n\n\n\n\n","category":"type"},{"location":"Models/gens/#LITS.FiveMassShaft","page":"Generator","title":"LITS.FiveMassShaft","text":"Parameters of 5 mass-spring shaft model. It contains a High-Pressure (HP) steam turbine, Intermediate-Pressure (IP) steam turbine, Low-Pressure (LP) steam turbine, the Rotor and an Exciter (EX) mover.\n\nConmutable structor\n\nFiveMassShaft(H, H_hp, H_ip, H_lp, H_ex,\n              D, D_hp, D_ip, D_lp, D_ex,\n              D_12, D_23, D_34, D_45,\n              K_hp, K_ip, K_lp, K_ex)\n\nArguments\n\nH   ::Float64 : Rotor inertia constant in MWs/MVA\nH_hp::Float64 : High pressure turbine inertia constant in MWs/MVA\nH_ip::Float64 : Intermediate pressure turbine inertia constant in MWs/MVA\nH_lp::Float64 : Low pressure turbine inertia constant in MWs/MVA\nH_ex::Float64 : Exciter inertia constant in MWs/MVA\nD   ::Float64 : Rotor natural damping in pu\nD_hp::Float64 : High pressure turbine natural damping in pu\nD_ip::Float64 : Intermediate pressure turbine natural damping in pu\nD_lp::Float64 : Low pressure turbine natural damping in pu\nD_ex::Float64 : Exciter natural damping in pu\nD_12::Float64 : High-Intermediate pressure turbine damping\nD_23::Float64 : Intermediate-Low pressure turbine damping\nD_34::Float64 : Low pressure turbine-Rotor damping\nD_45::Float64 : Rotor-Exciter damping\nK_hp::Float64 : High pressure turbine angle coefficient\nK_ip::Float64 : Intermediate pressure turbine angle coefficient\nK_lp::Float64 : Low pressure turbine angle coefficient\nK_ex::Float64 : Exciter angle coefficient\n\n\n\n\n\n","category":"type"},{"location":"Models/gens/#LITS.AVRFixed","page":"Generator","title":"LITS.AVRFixed","text":"Parameters of a AVR that returns a fixed voltage to the rotor winding:\n\nConmutable structor\n\nAVRFixed(Emf)\n\nArguments\n\nEmf   ::Float64 : Fixed voltage to the rotor winding\n\n\n\n\n\n","category":"type"},{"location":"Models/gens/#LITS.AVRSimple","page":"Generator","title":"LITS.AVRSimple","text":"Parameters of a simple proportional AVR in the derivative of EMF i.e. an integrator controller on EMF\n\nConmutable structor\n\nAVRSimple(Kv)\n\n#Arguments\n\nKv   ::Float64 : Integral Gain\n\n\n\n\n\n","category":"type"},{"location":"Models/gens/#LITS.AVRTypeI","page":"Generator","title":"LITS.AVRTypeI","text":"Parameters of an Automatic Voltage Regulator Type I - Resembles IEEE Type DC1\n\nConmutable structor\n\nAVRTypeI(Ka, Ke, Kf, Ta, Tf, Te, Tr, Vr_max, Vr_min, Ae, Be)\n\nArguments\n\nKa::Float64 : Amplifier Gain\nKe::Float64 : Field circuit integral deviation\nKf::Float64 : Stabilizer Gain in s * pu/pu\nTa::Float64 : Amplifier Time Constant in s\nTe::Float64 : Field Circuit Time Constant in s\nTf::Float64 : Stabilizer Time Constant in s\nTr::Float64 : Voltage Measurement Time Constant in s\nVr_max::Float64 : Maximum regulator voltage in pu\nVr_min::Float64 : Minimum regulator voltage in pu\nAe::Float64 : 1st ceiling coefficient\nBe::Float64 : 2nd ceiling coefficient\n\n\n\n\n\n","category":"type"},{"location":"Models/gens/#LITS.AVRTypeII","page":"Generator","title":"LITS.AVRTypeII","text":"Parameters of an Automatic Voltage Regulator Type II -  Typical static exciter model\n\nConmutable structor\n\nAVRTypeII(K0, T1, T2, T3, T4, Te, Tr, Vr_max, Vr_min, Ae, Be)\n\nArguments\n\nK0::Float64 : Regulator Gain\nT1::Float64 : First Pole in s\nT2::Float64 : First zero in s\nT3::Float64 : First Pole in s\nT4::Float64 : First zero in s\nTe::Float64 : Field Circuit Time Constant in s\nTr::Float64 : Voltage Measurement Time Constant in s\nVr_max::Float64 : Maximum regulator voltage in pu\nVr_min::Float64 : Minimum regulator voltage in pu\nAe::Float64 : 1st ceiling coefficient\nBe::Float64 : 2nd ceiling coefficient\n\n\n\n\n\n","category":"type"},{"location":"Models/gens/#LITS.PSSFixed","page":"Generator","title":"LITS.PSSFixed","text":"Parameters of a PSS that returns a fixed voltage to add to the reference for the AVR\n\nConmutable structor\n\nPSSFixed(Vs)\n\nArguments\n\nVs::Float64 : Fixed voltage stabilization signal\n\n\n\n\n\n","category":"type"},{"location":"Models/gens/#LITS.PSSSimple","page":"Generator","title":"LITS.PSSSimple","text":"Parameters of a PSS that returns a proportional droop voltage to add to the reference for the AVR\n\nConmutable structor\n\nPSSSimple(K_Ï‰, K_p)\n\nArguments\n\nK_Ï‰::Float64 : Proportional gain for frequency\nK_p::Float64 : Proportional gain for active power\n\n\n\n\n\n","category":"type"},{"location":"Models/gens/#LITS.TGFixed","page":"Generator","title":"LITS.TGFixed","text":"Parameters of a fixed Turbine Governor that returns a fixed mechanical torque given by the product of P_ref*efficiency\n\nConmutable structor\n\nTGFixed(efficiency)\n\nArguments\n\nefficiency::Float64 : Efficiency factor that multiplies P_ref\n\n\n\n\n\n","category":"type"},{"location":"Models/gens/#LITS.TGTypeI","page":"Generator","title":"LITS.TGTypeI","text":"Parameters of a Turbine Governor Type I.\n\nConmutable structor\n\nTGTypeI(R, Ts, Tc, T3, T4, T5, P_min, P_max)\n\nArguments\n\nR::Float64 : Droop parameter\nTs::Float64 : Governor time constant\nTc::Float64 : Servo time constant\nT3::Float64 : Transient gain time constant\nT4::Float64 : Power fraction time constant\nT5::Float64 : Reheat time constant\nP_min::Float64 : Min Power into the Governor\nP_max::Float64 : Max Power into the Governor\n\n\n\n\n\n","category":"type"},{"location":"Models/gens/#LITS.TGTypeII","page":"Generator","title":"LITS.TGTypeII","text":"Parameters of a Turbine Governor Type II.\n\nConmutable structor\n\nTGTypeI(R, T1, T2, Ï„_min, Ï„_max)\n\nArguments\n\nR::Float64 : Droop parameter\nT1::Float64 : Transient gain time constant\nT2::Float64 : Governor time constant\nÏ„_min::Float64 : Min turbine torque output\nÏ„_max::Float64 : Max turbine torque output\n\n\n\n\n\n","category":"type"},{"location":"Examples/example_OMIB/#Tutorial:-One-Machine-against-Infinite-Bus-(OMIB)-1","page":"Tutorial 1: OMIB","title":"Tutorial: One Machine against Infinite Bus (OMIB)","text":"","category":"section"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"This tutorial will introduce you to the functionality of LITS for running Power System Simulations. Note that this tutorial is for LITS 0.2.0. Future versions will have dedicated functions to find an equilibrium point and a proper functions for running perturbations without coding directly the callbacks.","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"This tutorial presents a simulation of a two-bus system, with an infinite bus (represented as a voltage source behind an impedance) at bus 1 and a classic machine on bus 2. The perturbation will be the trip of one of the two circuits (doubling its resistance and impedance) of the line that connects both buses.","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"This tutorial can be found on LITS/Examples repository.","category":"page"},{"location":"Examples/example_OMIB/#Step-1:-Package-Initialization-1","page":"Tutorial 1: OMIB","title":"Step 1: Package Initialization","text":"","category":"section"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"The first step consists in initialize all packages that will be used to run the simulation. All the necessary packages are listed:","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"using LITS\nusing PowerSystems\nusing NLsolve\nusing DiffEqBase\nusing Sundials\nconst PSY = PowerSystems","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"LITS and PowerSystems are used to properly define the data structure, while NLsolve, DiffEqBase and Sundials are used to formulate and solve the problem. Finally we call use can call PowerSystems functions using the PSY abbreviation.","category":"page"},{"location":"Examples/example_OMIB/#Step-2:-Data-creation-1","page":"Tutorial 1: OMIB","title":"Step 2: Data creation","text":"","category":"section"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"Next we need to define the different elements required to run a simulation. To run a simulation, it is required to define a DynamicSystem that requires the following components:","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"Vector of PSY.Bus elements, that define all the buses in the network.\nVector of PSY.Branch elements, that define all the branches elements (that connect two buses) in the network.\nVector of DynInjection elements, that define all the devices connected to buses that can inject (or withdraw) current, while also defining differential equations to model its dynamics.\nVector of PSY.Injection elements, that define all the devices connected to buses that can inject (or withdraw) current, without defining any differential equation.\nThe base of power used to define per unit values, in MVA as a Float64 value.\nThe base frequency used in the system, in Hz as a Float64 value.\n(Optional) Vector of DynBranch elements, that can be used to model lines with differential equations.","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"To start we will define the data structures for the network.","category":"page"},{"location":"Examples/example_OMIB/#Buses-and-Branches-1","page":"Tutorial 1: OMIB","title":"Buses and Branches","text":"","category":"section"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"As mentioned earlier, we require to create a Vector of PSY.Bus to define the buses in the network. Currently, some of the parameters are not used in LITS, but will be used once the initialization procedure is implemented.","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"#Define the vector of buses\nnodes_case1 = [PSY.Bus(1 , #number\n                   \"Bus 1\", #Name\n                   \"REF\" , #BusType (REF, PV, PQ)\n                   0, #Angle in radians\n                   1.05, #Voltage in pu\n                   (min=0.94, max=1.06), #Voltage limits in pu\n                   69), #Base voltage in kV\n                   PSY.Bus(2 , \"Bus 2\"  , \"PV\" , 0 , 1.0 , (min=0.94, max=1.06), 69)];","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"Note that two buses are defined in the vector nodes_case1. Similarly, to define the branches (that also has some parameters that are currently not used):","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"#Define the vector of branches\nbranch_case1 = [PSY.Line(\"Line1\", #name\n                     true, #available\n                     0.0, #active power flow initial condition (from-to)\n                     0.0, #reactive power flow initial condition (from-to)\n                     Arc(from=nodes_case1[1], to=nodes_case1[2]), #Connection between buses\n                     0.01, #resistance in pu\n                     0.05, #reactance in pu\n                     (from=0.0, to=0.0), #susceptance in pu\n                     18.046, #rate in MW\n                     1.04)];  #angle limits (-min and max)","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"Since we are interested in creating a fault that trips one of the two circuits of the line, we will create an additional Vector of branches with doubled impedance:","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"#Define the vector of branches under the fault\nbranch_case1_fault = [PSY.Line(\"Line1\", #name\n                           true, #available\n                           0.0, #active power flow initial condition (from-to)\n                           0.0, #reactive power flow initial condition (from-to)\n                           Arc(from=nodes_case1[1], to=nodes_case1[2]), #Connection between buses\n                           0.02, #resistance in pu\n                           0.1, #reactance in pu\n                           (from=0.0, to=0.0), #susceptance in pu\n                           18.046, #rate in MW\n                           1.04)];  #angle limits (-min and max)","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"Note that the resistance and reactance is doubled in comparison to the system without fault.","category":"page"},{"location":"Examples/example_OMIB/#Injection-devices-1","page":"Tutorial 1: OMIB","title":"Injection devices","text":"","category":"section"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"Secondly, we will define devices that can inject/withdraw electric current directly without defining differential equations. In this case we include a load and the voltage source that model the infinite bus.","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"loads_case1 = [PowerLoad(\"Bus1\", #name\n                         true, #available\n                         nodes_case1[2], #bus location\n                         PowerSystems.ConstantPower, #type\n                         0.3, #Active Power pu\n                         0.01, #Reactive power pu\n                         0.3, #Max Active Power pu\n                         0.01)]; #Max Reactive Power pu\n\ninf_gen_case1 = StaticSource(1, #number\n                :InfBus, #name\n                nodes_case1[1], #bus\n                1.05, #VR real part of voltage source\n                0.0, #VI imaginary part of voltage source\n                0.000001); #Xth","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"Note that loads are assumed as constant power for power flow purposes, but for dynamic simulations are converted to impedance loads assuming nominal voltage equals to 1 pu.","category":"page"},{"location":"Examples/example_OMIB/#Dynamic-Injection-devices-1","page":"Tutorial 1: OMIB","title":"Dynamic Injection devices","text":"","category":"section"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"Third, we define the Vector of DynInjection elements. In this case, we require to define a generator located in bus 2. For that purpose, we need to define its machine, shaft, automatic voltage regulator (AVR), turbine governor (TG) and power system stabilizer (PSS):","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"### Machine ###\ncase1_machine = BaseMachine(0.0, #R\n                            0.2995, #Xd_p\n                            0.7087, #eq_p\n                            100.0)  #MVABase\n\n######## Shaft Data #########\n\n### Shaft for Case 1 ###\ncase1_shaft = SingleMass(3.148, #H\n                     2.0) #D\n\n########  AVR Data #########\ncase1_avr = AVRFixed(0.0) #Vf not applicable in Classic Machines\n\n######## TG Data #########\n### No TG ###\ncase1234_no_tg = TGFixed(1.0) #eff\n\n######## PSS Data #########\n### No PSS ###\ncases_no_pss = PSSFixed(0.0) #No PSS without AVR\n\n### Constructing the Generator ###\ncase1_gen = DynGenerator(1, #Number\n                      :Case1Gen,\n                      nodes_case1[2], #bus\n                      1.0, # Ï‰_ref,\n                      1.0, #V_ref (only used in AVR)\n                      0.5, #P_ref\n                      case1_machine, #machine\n                      case1_shaft, #shaft\n                      case1_avr, #avr\n                      case1234_no_tg, #tg\n                      cases_no_pss) #pss","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"Note that a generator is defined by its 5 components, while also defining its reference for frequency, voltage and power.","category":"page"},{"location":"Examples/example_OMIB/#Defining-the-Dynamic-System-1","page":"Tutorial 1: OMIB","title":"Defining the Dynamic System","text":"","category":"section"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"Finally, with all the components properly constructed we define the dynamic system:","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"case1_DynSystem = DynamicSystem(nodes_case1, #Vector of Buses\n                              branch_case1, #Vector of Branches\n                              [case1_gen], #Vector of Dynamic Injections\n                              vcat(inf_gen_case1,loads_case1), #Vector of Injections\n                              100.0, #MVA Base\n                              60.0) #Freq. Base","category":"page"},{"location":"Examples/example_OMIB/#Step-3:-Initializing-the-problem-1","page":"Tutorial 1: OMIB","title":"Step 3: Initializing the problem","text":"","category":"section"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"The next step consists in finding an initial condition for the states. But first, we will explore some of the characteristics of our Dynamic System. All information (a ton) can be observed using dump(case1_DynSystem). The following methods can be used to return some information:","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"case1_DynSystem.buses: Return the vector of buses of the dynamic system.\ncase1_DynSystem.branches: Return the vector of branches of the dynamic system.\ncase1_DynSystem.dyn_injections: Return the vector of dynamic injections of the dynamic system.\ncase1_DynSystem.injections: Return the vector of dynamic injections of the dynamic system.\ncase1_DynSystem.DAE_vector: Return the vector of booleans of the dynamic system. Returns false or 0 for states that are algebraic and true or 1 for states that have derivative defined (differential states). The arrangement will put first the real part of the voltage buses and next the imaginary part. After that the differential states are defined.\ncase1_DynSystem.global_state_index: Return an array of dictionaries that have the order of the states in the entire vector state.","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"To initialize the problem we need to define an initial guess of the states:","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"#Initialize variables\ndx0 = zeros(LITS.get_total_rows(case1_DynSystem)) #Define a vector of zeros for the derivative\nx0 = [1.05, #VR_1\n      1.0, #VR_2\n      0.0, #VI_1\n      0.01, #VI_2\n      0.2, #Î´\n      1.0] #Ï‰\ntspan = (0.0, 30.0);","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"We will use NLsolve to find the initial condition of the system:","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"inif! = (out,x) -> LITS.system_model!(out, #output of the function\n                                      dx0, #derivatives equal to zero\n                                      x, #states\n                                       ([0.0],case1_DynSystem), #Parameters: [0.0] is not used\n                                        0.0) #time equals to zero.\nsys_solve = nlsolve(inif!, x0) #Solve using initial guess x0\nx0_init = sys_solve.zero","category":"page"},{"location":"Examples/example_OMIB/#Step-4:-Build-the-Simulation-1","page":"Tutorial 1: OMIB","title":"Step 4: Build the Simulation","text":"","category":"section"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"Next we will construct the simulation that we are interested to run. But first, we define the pertubation we are interested in model. LITS have two perturbations already implemented, that are a change in the mechanical power P_ref and a change on the admittance matrix Y_bus of the system. In this case we define a change in the admittance matrix:","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"#Compute Y_bus after fault\nYbus_fault = PSY.Ybus(branch_case1_fault, nodes_case1)[:,:] #Obtain Ybus for fault system\n\n#Define Fault using Callbacks\ncb = DiffEqBase.DiscreteCallback(LITS.change_t_one, #Change occurs at t=1\n                                 LITS.Y_change!) #Callback will change the Y_bus.","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"Now we define the simulation structure:","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"#Define Simulation Problem\nsim = DynamicSimulation(case1_DynSystem, #Dynamic System\n                        tspan, #Time span to simulate\n                        Ybus_fault, #Parameter that will be changed in the fault\n                        cb, #Callback\n                        x0_init) #Initial condition","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"Finally, to run the simulation:","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"#Solve problem in equilibrium\nrun_simulation!(sim, #simulation structure\n                IDA(), #Sundials DAE Solver\n                dtmax=0.02); #Arguments: Maximum timestep allowed","category":"page"},{"location":"Examples/example_OMIB/#Step-5:-Exploring-the-solution-1","page":"Tutorial 1: OMIB","title":"Step 5: Exploring the solution","text":"","category":"section"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"After running the simulation, our simulation structure sim will have the solution. For that sim.solution can be used to explore the solution structure. In this case sim.solution.t returns the vector of time, while sim.solution.u return the array of states. In addition, LITS have two functions to obtain different states of the solution:","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"get_state_series(sim, (:Case1Gen, :Î´)): can be used to obtain the solution as a tuple of time and the required state. In this case, we are obtaining the rotor angle :Î´ of the generator named :Case1Gen.\nget_voltagemag_series(sim, 2): can be used to obtain the voltage magnitude as a tuple of time and voltage. In this case, we are obtaining the voltage magnitude at bus 2 (where the generator is located).","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"using Plots\nangle = get_state_series(sim, (:Case1Gen, :Î´))\nplot(angle, xlabel=\"time\", ylabel=\"rotor angle [rad]\", label=\"rotor angle\")\n\nvolt = get_voltagemag_series(sim, 2)\nplot(volt, xlabel=\"time\", ylabel=\"Voltage [pu]\", label=\"V_2\")","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"<img src=\"../../assets/rotor_angle_OMIB.png\" width=\"75%\"/>","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"â €","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"<img src=\"../../assets/voltage_OMIB.png\" width=\"75%\"/>","category":"page"},{"location":"Examples/example_OMIB/#","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"â €","category":"page"},{"location":"Examples/example_lines/#Tutorial:-Dynamic-Lines-1","page":"Tutorial 2: Dynamic Lines","title":"Tutorial: Dynamic Lines","text":"","category":"section"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"This tutorial will introduce an example of considering dynamic lines in LITS. Note that this tutorial is for LITS 0.2.0. Future versions will have dedicated functions to find an equilibrium point and a proper functions for running perturbations without coding directly the callbacks.","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"This tutorial presents a simulation of a three-bus system, with an infinite bus (represented as a voltage source behind an impedance) at bus 1, and a one d- one q- machine on bus 2 and an inverter of 19 states, as a virtual synchronous machine at bus 3. The perturbation will be the trip of two of the three circuits (triplicating its resistance and impedance) of the line that connects bus 1 and bus 3. This case also consider a dynamic line model for connection between buses 2 and 3.","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"This tutorial can be found on LITS/Examples repository.","category":"page"},{"location":"Examples/example_lines/#Step-1:-Package-Initialization-1","page":"Tutorial 2: Dynamic Lines","title":"Step 1: Package Initialization","text":"","category":"section"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"using LITS\nusing PowerSystems\nusing NLsolve\nusing DiffEqBase\nusing Sundials\nconst PSY = PowerSystems","category":"page"},{"location":"Examples/example_lines/#Step-2:-Data-creation-1","page":"Tutorial 2: Dynamic Lines","title":"Step 2: Data creation","text":"","category":"section"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"To start we will define the data structures for the network.","category":"page"},{"location":"Examples/example_lines/#Buses-and-Branches-1","page":"Tutorial 2: Dynamic Lines","title":"Buses and Branches","text":"","category":"section"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"nodes_case9   = [Bus(1 , \"Bus 1\"  , \"REF\" , 0 , 1.02  , (min=0.94, max=1.06), 138),\n                    Bus(2 , \"Bus 2\"  , \"PV\" , 0 , 1.00 , (min=0.94, max=1.06), 138),\n                    Bus(3 , \"Bus 3\"  , \"PQ\" , 0 , 1.00 , (min=0.94, max=1.06), 138)]\n\nbranch_case9  =  [Line(\"Line1\", true, 0.0, 0.0, Arc(from=nodes_case9[1], to=nodes_case9[3]), 0.01, 0.12, (from=0.1, to=0.1), 100, 1.04),\n                    Line(\"Line2\", true, 0.0, 0.0, Arc(from=nodes_case9[1], to=nodes_case9[2]), 0.01, 0.12, (from=0.1, to=0.1), 100, 1.04)]\n\n#Trip of Line 1. Triplicates its impedance\nbranch_case9_fault = [Line(\"Line1\", true, 0.0, 0.0, Arc(from=nodes_case9[1], to=nodes_case9[3]), 0.03, 0.36, (from=0.03, to=0.03), 100, 1.04),\n    Line(\"Line2\", true, 0.0, 0.0, Arc(from=nodes_case9[1], to=nodes_case9[2]), 0.01, 0.12, (from=0.1, to=0.1), 100, 1.04)]\n\n#Dynamic Branch between nodes 2 and 3.\ndyn_branch9 = [LITS.DynLine(\"Line3\", true, Arc(from=nodes_case9[2], to=nodes_case9[3]), 0.02, 0.9, (from=0.5, to=0.5))];","category":"page"},{"location":"Examples/example_lines/#Injection-devices-1","page":"Tutorial 2: Dynamic Lines","title":"Injection devices","text":"","category":"section"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"loads_case9 =   [PowerLoad(\"Bus1\", true, nodes_case9[1], PowerSystems.ConstantPower, 0.5, 0.1, 1.5, 0.8),\n                   PowerLoad(\"Bus2\", true, nodes_case9[2], PowerSystems.ConstantPower, 1.0, 0.3, 1.5, 0.8),\n                   PowerLoad(\"Bus3\", true, nodes_case9[3], PowerSystems.ConstantPower, 0.3, 0.1, 0.5, 0.3)]\n\ninf_gen_case9 = StaticSource(1, #number\n                    :InfBus, #name\n                    nodes_case9[1],#bus\n                    1.00, #VR\n                    0.0, #VI\n                    0.000005); #Xth","category":"page"},{"location":"Examples/example_lines/#Dynamic-injection-devices-1","page":"Tutorial 2: Dynamic Lines","title":"Dynamic injection devices","text":"","category":"section"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"First we define our generator data:","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"######## Machine Data #########\n\n### Case: 4th Order Model with AVR (3-bus case) ###\ncase9_machine =  OneDOneQMachine(0.0, #R\n                                  1.3125, #Xd\n                                  1.2578, #Xq\n                                  0.1813, #Xd_p\n                                  0.25, #Xq_p\n                                  5.89, #Td0_p\n                                  0.6, #Tq0_p\n                                  100.0)   #MVABase\n\n######## Shaft Data #########\n\n### Shafts for Gen ###\ncase9_shaft = SingleMass(3.01, #H (M = 6.02 -> H = M/2)\n                            0.0) #D\n\n######## PSS Data #########\n\n### No PSS ###\ncases_no_pss = PSSFixed(0.0)\n\n\n######## TG Data #########\n\n### No TG ###\ncase9_no_tg = TGFixed(1.0) #eff\n\n\n########  AVR Data #########\n### AVRs for this case ###\ncase9_avr = AVRTypeI(20.0, #Ka - Gain\n                        0.01, #Ke\n                        0.063, #Kf\n                        0.2, #Ta\n                        0.314, #Te\n                        0.35, #Tf\n                        0.001, #Tr\n                        5.0, #Vrmax\n                        -5.0, #Vrmin\n                        0.0039, #Ae - 1st ceiling coefficient\n                        1.555) #Be - 2nd ceiling coefficient\n\n### Generators ###\ncase9_gen = DynGenerator(1, #Number\n                         :Case9Gen,\n                         nodes_case9[2], #bus\n                         1.0, # Ï‰_ref,\n                         1.0124, #V_ref\n                         0.6, #P_ref\n                         case9_machine, #machine\n                         case9_shaft, #shaft\n                         case9_avr, #avr\n                         case9_no_tg, #tg\n                         cases_no_pss); #pss","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"and for the inverter:","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"############### Inverter Data ########################\n\nconverter = AvgCnvFixedDC(138.0, #Rated Voltage\n                          100.0) #Rated MVA\n\ndc_source = FixedDCSource(1500.0) #Not in the original data, guessed.\n\nfilt = LCLFilter(0.08, #Series inductance lf in pu\n                   0.003, #Series resitance rf in pu\n                   0.074, #Shunt capacitance cf in pu\n                   0.2, #Series reactance rg to grid connection (#Step up transformer or similar)\n                   0.01) #Series resistance lg to grid connection (#Step up transformer or similar)\n\npll = PLL(500.0, #Ï‰_lp: Cut-off frequency for LowPass filter of PLL filter.\n          0.084, #k_p: PLL proportional gain\n          4.69) #k_i: PLL integral gain\n\nvirtual_H = VirtualInertia(2.0, #Ta:: VSM inertia constant\n                           400.0, #kd:: VSM damping coefficient\n                           20.0, #kÏ‰:: Frequency droop gain in pu\n                           2*pi*50.0) #Ï‰b:: Rated angular frequency\n\nQ_control = ReactivePowerDroop(0.2, #kq:: Reactive power droop gain in pu\n                              1000.0) #Ï‰f:: Reactive power cut-off low pass filter frequency\n\nouter_control = VirtualInertiaQdroop(virtual_H, Q_control)\n\nvsc = CombinedVIwithVZ(0.59, #kpv:: Voltage controller proportional gain\n                       736.0, #kiv:: Voltage controller integral gain\n                       0.0, #kffv:: Binary variable enabling the voltage feed-forward in output of current controllers\n                       0.0, #rv:: Virtual resistance in pu\n                       0.2, #lv: Virtual inductance in pu\n                       1.27, #kpc:: Current controller proportional gain\n                       14.3, #kiv:: Current controller integral gain\n                       0.0, #kffi:: Binary variable enabling the current feed-forward in output of current controllers\n                       50.0, #Ï‰ad:: Active damping low pass filter cut-off frequency\n                       0.2) #kad:: Active damping gain\n\ncase9_inv = DynInverter(2, #number\n                             :DARCO, #name\n                             nodes_case9[3], #bus location\n                             1.0, #Ï‰_ref\n                             0.8, #V_ref\n                             0.5, #P_ref\n                             -0.3, #Q_ref\n                             100.0, #MVABase\n                             converter, #Converter\n                             outer_control, #OuterControl\n                             vsc, #Voltage Source Controller\n                             dc_source, #DC Source\n                             pll, #Frequency Estimator\n                             filt); #Output Filter","category":"page"},{"location":"Examples/example_lines/#Dynamic-System-1","page":"Tutorial 2: Dynamic Lines","title":"Dynamic System","text":"","category":"section"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"case9_DynSystem = DynamicSystem(nodes_case9, #Vector of Buses\n                                 branch_case9, #Vector of Branches\n                                 [case9_inv, case9_gen], #Vector of Dynamic Injections\n                                 vcat(inf_gen_case9, loads_case9), #Vector of Injections\n                                 100.0, #MVA Base\n                                 50.0, #Freq. Base\n                                 dyn_branch9); #Vector of Dynamic Branches","category":"page"},{"location":"Examples/example_lines/#Step-3:-Initializing-the-problem-1","page":"Tutorial 2: Dynamic Lines","title":"Step 3: Initializing the problem","text":"","category":"section"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"To initialize the problem we need to define an initial guess of the states:","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"dx0 = zeros(LITS.get_total_rows(case9_DynSystem))\nx0 = [1.00, #V1_R\n          1.00, #V2_R\n          1.00, #V3_R\n          0.0, #V1_I\n         -0.01, #V2_I\n         -0.01, #V3_I\n         0.0, #Î´Ï‰_vsm\n          0.2, #Î´Î¸_vsm\n          0.025, #qm\n          0.0015, #Î¾_d\n          -0.07, #Î¾_q\n          0.05, #Î³_d\n        -0.001, #Î³_q\n         0.95, #Ï•_d\n         -0.10, #Ï•_q\n         1.004, #vpll_d\n         0.0, #vpll_q\n         0.0, #Îµ_pll\n         0.1, #Î´Î¸_pll\n         0.5, #id_cv\n         0.0, #iq_cv\n         0.95, #vod\n         -0.1, #voq\n         0.49, #iod\n        -0.1, #ioq\n          1.0, #eq_p\n          0.47, #ed_p\n          0.6, #Î´\n          1.0, #Ï‰\n          2.1, #Vf\n          0.28, #Vr1\n          -0.39, #Vr2,\n          1.0, #Vm\n          0.5, #IL1_R\n          0.5] #IL1_I\n\ncase9_inv.inner_vars[13] = 0.95 #Initialize internal variables of inverter: Vd_cnv var\ncase9_inv.inner_vars[14] = -0.1 #Initialize internal variables of inverter: Vq_cnv var\ntspan = (0.0, 30.0);","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"We will use NLsolve to find the initial condition of the system:","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"#Find initial condition\ninif! = (out,x) -> LITS.system_model!(out, dx0 ,x, ([0.0],case9_DynSystem), 0.0)\nsys_solve = nlsolve(inif!, x0, xtol=:1e-8,ftol=:1e-8,method=:trust_region)\nx0_init = sys_solve.zero","category":"page"},{"location":"Examples/example_lines/#Step-4:-Build-the-Simulation-1","page":"Tutorial 2: Dynamic Lines","title":"Step 4: Build the Simulation","text":"","category":"section"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"#Compute Y_bus after fault\nYbus_fault = Ybus(branch_case9_fault, nodes_case9)[:,:]\n\n#Define Fault using Callbacks\ncb = DiffEqBase.DiscreteCallback(LITS.change_t_one, LITS.Y_change!)\n\n#Define Simulation Problem\nsim = DynamicSimulation(case9_DynSystem, tspan, Ybus_fault, cb, x0_init)\n\n#Solve problem\nrun_simulation!(sim, IDA());","category":"page"},{"location":"Examples/example_lines/#Step-5:-Explore-the-solution-1","page":"Tutorial 2: Dynamic Lines","title":"Step 5: Explore the solution","text":"","category":"section"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"using Plots\nvolt = get_voltagemag_series(sim, 2)\nplot(volt, xlabel=\"time\", ylabel=\"Voltage [pu]\", label=\"V_2\")\n\nzoom = [(volt[1][ix], volt[2][ix]) for (ix, s) in enumerate(volt[1]) if (s > 0.90 && s < 1.6)]\nplot(zoom, xlabel=\"time\", ylabel=\"Voltage [pu]\", label=\"V_2\")","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"<img src=\"../../assets/voltage_lines.png\" width=\"75%\"/>","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"â €","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"<img src=\"../../assets/voltage_zoom_lines.png\" width=\"75%\"/>","category":"page"},{"location":"Examples/example_lines/#","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"â €","category":"page"},{"location":"#LITS.jl-1","page":"Home","title":"LITS.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"LITS.jl is a Julia package for doing Power Systems Dynamic Modeling with Low Inertia Energy Sources.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"You can install it by typing","category":"page"},{"location":"#","page":"Home","title":"Home","text":"pkg> add LITS","category":"page"},{"location":"#Usage-1","page":"Home","title":"Usage","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Once installed, the LITS package can by used by typing:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using LITS","category":"page"},{"location":"#Structure-1","page":"Home","title":"Structure","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The following figure shows the interactions between LITS.jl, PowerSystems.jl, DifferentialEquations.jl and the integrators. The architecture of LITS.jl  is such that the power system models are all self-contained and return the model function evaluations. The Jacobian is calculated through DifferentialEquations.jl's common-interface enabling the use of any solver available in Julia. Considering that the resulting models are differential-algebraic equations (DAE), the implementation focuses on the use of implicit solvers, in particular SUNDIALS since it has exceptional features applicable to large models â€” for instance, interfacing with distributed linear-solvers and GPU arrays.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"<img src=\"docs/src/assets/SoftwareLoop.png\" width=\"50%\"/>","category":"page"},{"location":"#","page":"Home","title":"Home","text":"â €","category":"page"},{"location":"#Contents-1","page":"Home","title":"Contents","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n  \"Examples/example_OMIB.md\",\n  \"Examples/example_lines.md\",\n  \"Models/network.md\",\n  \"Models/gens.md\",\n  \"Models/inverters.md\",\n]","category":"page"},{"location":"docs/#Documentation-1","page":"Documentation","title":"Documentation","text":"","category":"section"},{"location":"docs/#Requirements-1","page":"Documentation","title":"Requirements","text":"","category":"section"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"Pkg.add(\"Documenter\")","category":"page"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"pip install ghp-import","category":"page"},{"location":"docs/#Run-1","page":"Documentation","title":"Run","text":"","category":"section"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"cd docs\nmake html\nopen build/index.html","category":"page"}]
}
